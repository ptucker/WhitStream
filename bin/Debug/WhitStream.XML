<?xml version="1.0"?>
<doc>
    <assembly>
        <name>WhitStream</name>
    </assembly>
    <members>
        <member name="T:WhitStream.Admin.AdminForm">
            <summary>
            Form for monitoring and administering to the WhitStream Server
            </summary>
        </member>
        <member name="M:WhitStream.Admin.AdminForm.#ctor">
            <summary> Simple constructor </summary>
        </member>
        <member name="P:WhitStream.Admin.AdminForm.Scheduler">
            <summary>Get and set the scheduler currently executing</summary>
        </member>
        <member name="M:WhitStream.Admin.AdminForm.UpdateStats">
            <summary> Update the interface </summary>
        </member>
        <member name="F:WhitStream.Admin.AdminForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:WhitStream.Admin.AdminForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:WhitStream.Admin.AdminForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:WhitStream.Database.RelationTable">
            <summary>
            Class to hold persistent data with simple, database-like operations
            </summary>
        </member>
        <member name="M:WhitStream.Database.RelationTable.#ctor(System.String[],System.Type[],System.Int32[])">
            <summary>
            Constructor for a Relation Table
            </summary>
            <param name="names">The names of the table's columns</param>
            <param name="types">The types of the table's columns</param>
            <param name="keys">The columns which will be primary keys</param>
        </member>
        <member name="M:WhitStream.Database.RelationTable.Drop(System.Object[])">
            <summary>
            Drop the DataRow matching the primary keys
            </summary>
            <param name="keys">The values of the matching the primary columns</param>
        </member>
        <member name="M:WhitStream.Database.RelationTable.Drop(System.Data.DataRow)">
            <summary>
            Drops a given DataRow from the table
            </summary>
            <param name="dropRow">The DataRow from the table to drop</param>
        </member>
        <member name="M:WhitStream.Database.RelationTable.Add(System.Data.DataRow)">
            <summary>
            Add an array of objects to the datatable
            </summary>
            <param name="drow">The DataRow to add to the table</param>
        </member>
        <member name="M:WhitStream.Database.RelationTable.GetRow">
            <summary>
            Add a DataRow for which will added later
            </summary>
            <returns>The new DataRow</returns>
            <remarks>The row must be added to the RelationTable with the add function</remarks>
        </member>
        <member name="M:WhitStream.Database.RelationTable.Find(System.Object[])">
            <summary>
            Finds a DataRow that matches the given primary keys
            </summary>
            <param name="keys">The values of the primary columns</param>
            <returns></returns>
        </member>
        <member name="M:WhitStream.Database.RelationTable.Find(System.String)">
            <summary>
            Finds all the DataRows which match a given expression
            </summary>
            <param name="expression">The expression to query on</param>
            <returns></returns>
        </member>
        <member name="P:WhitStream.Database.RelationTable.Rows">
            <summary>The number of rows in the table</summary>
        </member>
        <member name="T:WhitStream.Expression.IAtom">
            <summary>
            Interface to model Atom objects in an expression (Constants and Values)
            </summary>
        </member>
        <member name="M:WhitStream.Expression.IAtom.Val(WhitStream.Data.DataItem[])">
            <summary>
            Function to get the value of this specific atom object
            </summary>
            <param name="dis">The current data items</param>
            <returns>The value of this atom</returns>
            <seealso cref="T:WhitStream.Data.DataItem" />
        </member>
        <member name="T:WhitStream.Expression.Constant">
            <summary>
            Class to model constants in an expression
            </summary>
            <seealso cref="T:WhitStream.Expression.IAtom" />
            <seealso cref="T:WhitStream.Expression.IExpr" />
        </member>
        <member name="F:WhitStream.Expression.Constant.constVal">
            <summary>
            The value of this atom
            </summary>
        </member>
        <member name="M:WhitStream.Expression.Constant.#ctor">
            <summary>
            Default constructor for creating an empty Constant object
            </summary>
        </member>
        <member name="M:WhitStream.Expression.Constant.#ctor(System.Object)">
            <summary>
            Constructor for creating a Constant object with a specific object.
            If the object is a string prefaced by ', then it is a string object
            If the object is a string prefaced by B, then it is a Byte object
            If the object is a string prefaced by S, then it is a ushort (uInt16) object
            If the object is a string prefaced by I, then it is an uint (uInt32) object
            Else the object is parsed as a Int32
            </summary>
            <param name="obj">The object to store</param>
        </member>
        <member name="M:WhitStream.Expression.Constant.Val(WhitStream.Data.DataItem[])">
            <summary>
            Return the value of this object.
            As it is a Constant objects, the incoming DataItem objects are ignored
            </summary>
            <param name="dis">The current DataItem objects</param>
            <returns>The constant value</returns>
        </member>
        <member name="M:WhitStream.Expression.Constant.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            The evaluation of this constant as an expression
            </summary>
            <param name="dis">The current DataItem objects</param>
            <returns>True always</returns>
        </member>
        <member name="T:WhitStream.Expression.Value">
            <summary>
            Class to model DataItem values
            </summary>
            <seealso cref="T:WhitStream.Expression.IAtom" />
            <seealso cref="T:WhitStream.Expression.IExpr" />
        </member>
        <member name="F:WhitStream.Expression.Value.attrVal">
            <summary>
            The attribute from the DataItem to retrieve
            </summary>
        </member>
        <member name="F:WhitStream.Expression.Value.iData">
            <summary>
            Which DataItem to retreive from from the incoming array
            </summary>
        </member>
        <member name="M:WhitStream.Expression.Value.#ctor">
            <summary>
            Default constructor for making an empty Value object
            </summary>
        </member>
        <member name="M:WhitStream.Expression.Value.#ctor(System.Int32,System.Int32)">
            <summary>
            The constructor for making a Value object with know attribute and data item
            </summary>
            <param name="i">Which DataItem object to fetch from</param>
            <param name="attr">Which attribute to fetch from</param>
            <returns>The value from the appropriate DataItem object</returns>
            <seealso cref="T:WhitStream.Data.DataItem" />
        </member>
        <member name="M:WhitStream.Expression.Value.Val(WhitStream.Data.DataItem[])">
            <summary>
            The value of this Value object
            </summary>
            <param name="dis">The DataItem objects to read from</param>
            <returns>The appropriate value</returns>
        </member>
        <member name="M:WhitStream.Expression.Value.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            The evaluation of this Value as an expression
            </summary>
            <param name="dis">The current DataItem objects</param>
            <returns>True always</returns>
        </member>
        <member name="T:WhitStream.Expression.BinaryCompOp">
            <summary>
            Models general behavior for all comparison operators (including '=' and '&lt;')
            We assume that comparison operators only work on Atom objects, and not
            other comparison objects (e.g., we don't support a = b = c)
            </summary>
            <seealso cref="T:WhitStream.Expression.IAtom" />
        </member>
        <member name="F:WhitStream.Expression.BinaryCompOp.latom">
            <summary>
            The left operand
            </summary>
        </member>
        <member name="F:WhitStream.Expression.BinaryCompOp.ratom">
            <summary>
            The left operand
            </summary>
        </member>
        <member name="M:WhitStream.Expression.BinaryCompOp.#ctor(WhitStream.Expression.IAtom,WhitStream.Expression.IAtom)">
            <summary>
            Generic constructor for Comparison operators.
            </summary>
            <param name="l">The left operand</param>
            <param name="r">The right operand</param>
        </member>
        <member name="M:WhitStream.Expression.BinaryCompOp.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            Evaluates this comparison, given any DataItem objects that are relevant
            </summary>
            <param name="dis">The DataItem objects that are involved in the comparison</param>
            <returns>True if the operator passes, False if it fails</returns>
            <seealso cref="T:WhitStream.Data.DataItem" />
            <seealso cref="T:WhitStream.Expression.IExpr" />
        </member>
        <member name="T:WhitStream.Expression.UnaryLogOp">
            <summary>
            Models general behavior for all unary logical operators (e.g. NOT)
            </summary>
        </member>
        <member name="F:WhitStream.Expression.UnaryLogOp.expr">
            <summary>
            The operand for this operator
            </summary>
        </member>
        <member name="M:WhitStream.Expression.UnaryLogOp.#ctor">
            <summary>
            Default constructor for an empty logical operator
            </summary>
        </member>
        <member name="M:WhitStream.Expression.UnaryLogOp.#ctor(WhitStream.Expression.IExpr)">
            <summary>
            Constructor for the case when the operand is known
            </summary>
        </member>
        <member name="P:WhitStream.Expression.UnaryLogOp.Expr">
            <summary>
            Property to set the expression for this operator
            </summary>
        </member>
        <member name="M:WhitStream.Expression.UnaryLogOp.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            Evaluate this operator, given the relevant DataItem objects
            </summary>
            <param name="dis">The current DataItem objects</param>
            <returns>True if the operator passes, False if it fails</returns>
            <seealso cref="T:WhitStream.Data.DataItem" />
            <seealso cref="T:WhitStream.Expression.IExpr" />
        </member>
        <member name="T:WhitStream.Expression.BinaryLogOp">
            <summary>
            Models general behavior for binary logical operators (e.g. AND, OR)
            </summary>
        </member>
        <member name="F:WhitStream.Expression.BinaryLogOp.lexpr">
            <summary>
            The left operand for this operator
            </summary>
        </member>
        <member name="F:WhitStream.Expression.BinaryLogOp.rexpr">
            <summary>
            The right operand for this operator
            </summary>
        </member>
        <member name="M:WhitStream.Expression.BinaryLogOp.#ctor">
            <summary>
            Default constructor for an empty binary logical operator
            </summary>
        </member>
        <member name="M:WhitStream.Expression.BinaryLogOp.#ctor(WhitStream.Expression.IExpr,WhitStream.Expression.IExpr)">
            <summary>
            Constructor for setting both operands for this operator
            </summary>
            <param name="l">The left operand</param>
            <param name="r">The right operand</param>
            <seealso cref="T:WhitStream.Expression.IExpr" />
        </member>
        <member name="P:WhitStream.Expression.BinaryLogOp.LExpr">
            <summary>
            Property for setting the left operand for this operator
            </summary>
        </member>
        <member name="P:WhitStream.Expression.BinaryLogOp.RExpr">
            <summary>
            Property for setting the right operand for this operator
            </summary>
        </member>
        <member name="M:WhitStream.Expression.BinaryLogOp.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            Evaluate this operator based on the relevant DataItem objects
            </summary>
            <param name="dis">The DataItem objects for evaluating this expression</param>
            <returns>True if the expression passes, false otherwise</returns>
            <seealso cref="T:WhitStream.Data.DataItem" />
            <seealso cref="T:WhitStream.Expression.IExpr" />
        </member>
        <member name="T:WhitStream.Expression.OpEQ">
            <summary>
            Models the comparison operator EQUALS (=)
            </summary>
        </member>
        <member name="M:WhitStream.Expression.OpEQ.#ctor(WhitStream.Expression.IAtom,WhitStream.Expression.IAtom)">
            <summary>
            Constructor for OpEQ, to compare l=r
            </summary>
            <param name="l">Left operand</param>
            <param name="r">Right operand</param>
            <seealso cref="T:WhitStream.Expression.IAtom" />
        </member>
        <member name="M:WhitStream.Expression.OpEQ.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            Compares the two atoms for equality
            </summary>
            <param name="dis">The data items for comparison</param>
            <returns>True if left operand is equal to right operand, false otherwise</returns>
            <seealso cref="T:WhitStream.Expression.IAtom" />
        </member>
        <member name="T:WhitStream.Expression.OpNE">
            <summary>
            Models the comparison operator NOT EQUALS (!=)
            </summary>
        </member>
        <member name="M:WhitStream.Expression.OpNE.#ctor(WhitStream.Expression.IAtom,WhitStream.Expression.IAtom)">
            <summary>
            Constructor for OpNE, to compare l!=r
            </summary>
            <param name="l">Left operand</param>
            <param name="r">Right operand</param>
            <seealso cref="T:WhitStream.Expression.IAtom" />
        </member>
        <member name="M:WhitStream.Expression.OpNE.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            Compares the two atoms for inequality
            </summary>
            <param name="dis">The data items for comparison</param>
            <returns>True if left operand is not equal to right operand, false otherwise</returns>
            <seealso cref="T:WhitStream.Expression.IAtom" />
        </member>
        <member name="T:WhitStream.Expression.OpGR">
            <summary>
            Models the comparison operator GREATER THAN (&gt;)
            </summary>
        </member>
        <member name="M:WhitStream.Expression.OpGR.#ctor(WhitStream.Expression.IAtom,WhitStream.Expression.IAtom)">
            <summary>
            Constructor for OpGR, to compare l&gt;r
            </summary>
            <param name="l">Left operand</param>
            <param name="r">Right operand</param>
            <seealso cref="T:WhitStream.Expression.IAtom" />
        </member>
        <member name="M:WhitStream.Expression.OpGR.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            Compares the two atoms to see if left is greater than right
            </summary>
            <param name="dis">The data items for comparison</param>
            <returns>True if left operand is greater than right operand, false otherwise</returns>
            <remarks>The two operands must support IComparable, and must be able to be
            compared to each other</remarks>
            <seealso cref="T:WhitStream.Expression.IAtom" />
            <seealso cref="T:System.IComparable" />
        </member>
        <member name="T:WhitStream.Expression.OpLT">
            <summary>
            Models the comparison operator LESS THAN (&lt;)
            </summary>
        </member>
        <member name="M:WhitStream.Expression.OpLT.#ctor(WhitStream.Expression.IAtom,WhitStream.Expression.IAtom)">
            <summary>
            Constructor for OpLT, to compare l&lt;r
            </summary>
            <param name="l">Left operand</param>
            <param name="r">Right operand</param>
            <seealso cref="T:WhitStream.Expression.IAtom" />
        </member>
        <member name="M:WhitStream.Expression.OpLT.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            Compares the two atoms to see if left is less than right
            </summary>
            <param name="dis">The data items for comparison</param>
            <returns>True if left operand is less than right operand, false otherwise</returns>
            <remarks>The two operands must support IComparable, and must be able to be
            compared to each other</remarks>
            <seealso cref="T:WhitStream.Expression.IAtom" />
            <seealso cref="T:System.IComparable" />
        </member>
        <member name="T:WhitStream.Expression.OpGE">
            <summary>
            Models the comparison operator GREATER THAN OR EQUAL TO (&gt;=)
            </summary>
        </member>
        <member name="M:WhitStream.Expression.OpGE.#ctor(WhitStream.Expression.IAtom,WhitStream.Expression.IAtom)">
            <summary>
            Constructor for OpGE, to compare l&gt;=r
            </summary>
            <param name="l">Left operand</param>
            <param name="r">Right operand</param>
            <seealso cref="T:WhitStream.Expression.IAtom" />
        </member>
        <member name="M:WhitStream.Expression.OpGE.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            Compares the two atoms to see if left is greater than or equal to right
            </summary>
            <param name="dis">The data items for comparison</param>
            <returns>True if left operand is greater than or equal to right operand, false otherwise</returns>
            <remarks>The two operands must support IComparable, and must be able to be
            compared to each other</remarks>
            <seealso cref="T:WhitStream.Expression.IAtom" />
            <seealso cref="T:System.IComparable" />
        </member>
        <member name="T:WhitStream.Expression.OpLE">
            <summary>
            Models the comparison operator LESS THAN OR EQUAL TO (&lt;=)
            </summary>
        </member>
        <member name="M:WhitStream.Expression.OpLE.#ctor(WhitStream.Expression.IAtom,WhitStream.Expression.IAtom)">
            <summary>
            Constructor for OpGE, to compare l&lt;=r
            </summary>
            <param name="l">Left operand</param>
            <param name="r">Right operand</param>
            <seealso cref="T:WhitStream.Expression.IAtom" />
        </member>
        <member name="M:WhitStream.Expression.OpLE.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            Compares the two atoms to see if left is less than or equal to right
            </summary>
            <param name="dis">The data items for comparison</param>
            <returns>True if left operand is less than or equal to right operand, false otherwise</returns>
            <remarks>The two operands must support IComparable, and must be able to be
            compared to each other</remarks>
            <seealso cref="T:WhitStream.Expression.IAtom" />
            <seealso cref="T:System.IComparable" />
        </member>
        <member name="T:WhitStream.Expression.OpAND">
            <summary>
            Models the logical AND operator
            </summary>
        </member>
        <member name="M:WhitStream.Expression.OpAND.#ctor">
            <summary>
            Default constructor to create an empty AND operator
            </summary>
        </member>
        <member name="M:WhitStream.Expression.OpAND.#ctor(WhitStream.Expression.IExpr,WhitStream.Expression.IExpr)">
            <summary>
            Constructor to create an OR operator with known operands
            </summary>
            <param name="l">The left operand</param>
            <param name="r">The right operand</param>
        </member>
        <member name="M:WhitStream.Expression.OpAND.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            Evaluate the operand with logical AND
            </summary>
            <param name="dis">The data items to operate with</param>
            <returns>True if both expressions are true, false otherwise</returns>
        </member>
        <member name="T:WhitStream.Expression.OpOR">
            <summary>
            Models the logical OR operator
            </summary>
        </member>
        <member name="M:WhitStream.Expression.OpOR.#ctor">
            <summary>
            Default constructor to create an empty OR operator
            </summary>
        </member>
        <member name="M:WhitStream.Expression.OpOR.#ctor(WhitStream.Expression.IExpr,WhitStream.Expression.IExpr)">
            <summary>
            Constructor to create an OR operator with known operands
            </summary>
            <param name="l">The left operand</param>
            <param name="r">The right operand</param>
        </member>
        <member name="M:WhitStream.Expression.OpOR.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            Evaluate the operand with logical OR
            </summary>
            <param name="dis">The data items to operate with</param>
            <returns>True if either the left or right operand are true, false otherwise</returns>
        </member>
        <member name="T:WhitStream.Expression.OpNOT">
            <summary>
            Models the logical NOT operator
            </summary>
        </member>
        <member name="M:WhitStream.Expression.OpNOT.#ctor">
            <summary>
            Default constructor to create an empty NOT operator
            </summary>
        </member>
        <member name="M:WhitStream.Expression.OpNOT.#ctor(WhitStream.Expression.IExpr)">
            <summary>
            Constructor to create an NOT operator with known operand
            </summary>
            <param name="e">The operand</param>
        </member>
        <member name="M:WhitStream.Expression.OpNOT.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            Evaluate the operand with logical NOT
            </summary>
            <param name="dis">The data items to operate with</param>
            <returns>True if the expression is false, false otherwise</returns>
        </member>
        <member name="T:WhitStream.Expression.IExpr">
            <summary>
            Interface for all expression objects
            </summary>
        </member>
        <member name="M:WhitStream.Expression.IExpr.Evaluate(WhitStream.Data.DataItem[])">
            <summary>
            Function to determine if an expression object evaluates to
            true or false, based on the current array of DataItem objects
            </summary>
            <param name="dis">The current DataItem objects</param>
            <returns>True if this expression evaluates to true, false otherwise</returns>
            <seealso cref="T:WhitStream.Data.DataItem" />
        </member>
        <member name="T:WhitStream.Expression.ExprParser">
            <summary>
            Models expression parsing
            </summary>
        </member>
        <member name="F:WhitStream.Expression.ExprParser.tokens">
            <summary>
            Tokens to parse out of the string
            </summary>
        </member>
        <member name="M:WhitStream.Expression.ExprParser.Parse(System.String)">
            <summary>
            Parse the string predicate so it can be evaluated over the incoming DataItem objects
            </summary>
            <param name="stExpr">The predicate in String format</param>
            <returns>An IExpr object for evaluating this predicate</returns>
            <seealso cref="T:WhitStream.Expression.IExpr" />
        </member>
        <member name="M:WhitStream.Expression.ExprParser.preprocess(System.String@)">
            <summary>
            Preprocess the incoming string to prepare it for parsing.
            </summary>
            <param name="st">The predicate string</param>
        </member>
        <member name="M:WhitStream.Expression.ExprParser.ParseExpr(System.String[],System.Int32@,System.Collections.Generic.Stack{WhitStream.Expression.IExpr})">
            <summary>
            Parses an individual expression (e.g. $1.4 = 10)
            </summary>
            <param name="rgstExprs">The expression pieces of the predicate string</param>
            <param name="i">Which expression to focus on</param>
            <param name="stk">The current stack</param>
            <returns>An IExpr representation of the expression</returns>
            <seealso cref="T:WhitStream.Expression.IExpr" />
        </member>
        <member name="M:WhitStream.Expression.ExprParser.ParseAtom(System.String)">
            <summary>
            Parse a single Atom object from the string
            </summary>
            <param name="st">The string represenation of the Atom</param>
            <returns>The resulting IAtom object</returns>
            <seealso cref="T:WhitStream.Expression.IAtom" />
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpUnion">
            <summary>
            Models the query operator Union
            </summary>
            <remarks>Since this operator is non-blocking, it uses the trivial final function</remarks>
            <seealso cref="M:WhitStream.QueryEngine.Query.FinalTrivial(System.Collections.Generic.List{WhitStream.Data.DataItem})"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpUnion.#ctor">
            <summary>
            Default constructor for Union
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpUnion.#ctor(WhitStream.QueryEngine.Query,WhitStream.QueryEngine.Query)">
            <summary> Constructor for Union </summary>
            <param name="opInL">The left input query operator</param>
            <param name="opInR">The right input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpUnion.#ctor(System.String,WhitStream.QueryEngine.Query,WhitStream.QueryEngine.Query)">
            <summary> Constructor for Union </summary>
            <param name="id">ID for this operator</param>
            <param name="opInL">The left input query operator</param>
            <param name="opInR">The right input query operator</param>
            <remarks>Should only be used with deserialization</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpUnion.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpUnion.SerializeOp(System.IO.TextWriter)">
            <summary> Serialize this Union operator </summary>
            <param name="tw">Destination for XML data</param>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpUnion.Naive">
            <summary>
            Naive implementation for union
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpUnion.Naive.FnStepLeft">
            <summary>Step functionality for union</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpUnion.Naive.FnStepRight">
            <summary>Step functionality for union</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpUnion.Naive.FnStepListLeft">
            <summary>StepList functionality for union</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpUnion.Naive.FnStepListRight">
            <summary>StepList functionality for union</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpUnion.Naive.FnPropLeft">
            <summary>Prop functionality for union</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpUnion.Naive.FnPropRight">
            <summary>Prop functionality for union</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpIntersect">
            <summary>
            Models the query operator Intersect
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpIntersect.#ctor">
            <summary>
            Default constructor for Intersect
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpIntersect.#ctor(WhitStream.QueryEngine.Query,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Intersect
            </summary>
            <param name="opInL">The left input query operator</param>
            <param name="opInR">The right input query operator</param>
            <returns></returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpIntersect.#ctor(System.String,WhitStream.QueryEngine.Query,WhitStream.QueryEngine.Query)">
            <summary> Constructor for Intersect </summary>
            <param name="id">ID for this operator</param>
            <param name="opInL">The left input query operator</param>
            <param name="opInR">The right input query operator</param>
            <remarks>Should only be used with deserialization</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpIntersect.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpIntersect.SerializeOp(System.IO.TextWriter)">
            <summary> Serialize this operator </summary>
            <param name="tw">Destination for XML data</param>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpIntersect.Naive">
            <summary>
            Naive implementation for Intersect
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpIntersect.Naive.StateSize">
            <summary> How many data items are curently held in state </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpIntersect.Naive.FnStepLeft">
            <summary>Step functionality for intersect</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpIntersect.Naive.FnStepRight">
            <summary>Step functionality for intersect</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpIntersect.Naive.FnPropLeft">
            <summary>Prop functionality for intersect</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpIntersect.Naive.FnPropRight">
            <summary>Prop functionality for intersect</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpIntersect.Naive.FnKeepLeft">
            <summary>Keep functionality for intersect</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpIntersect.Naive.FnKeepRight">
            <summary>Keep functionality for intersect</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpIntersect.Naive.FnFinalLeft">
            <summary>Final functionality for intersect</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpIntersect.Naive.FnFinalRight">
            <summary>Final functionality for intersect</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpDifference">
            <summary>
            Models the query operator Set Difference
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpDifference.#ctor">
            <summary>
            Default constructor for Difference
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpDifference.#ctor(WhitStream.QueryEngine.Query,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Difference
            </summary>
            <param name="opInL">The left (positive) input query operator</param>
            <param name="opInR">The right (negative) input query operator</param>
            <returns></returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpDifference.#ctor(System.String,WhitStream.QueryEngine.Query,WhitStream.QueryEngine.Query)">
            <summary> Constructor for Union </summary>
            <param name="id">ID for this operator</param>
            <param name="opInL">The left input query operator</param>
            <param name="opInR">The right input query operator</param>
            <remarks>Should only be used with deserialization</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpDifference.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpDifference.SerializeOp(System.IO.TextWriter)">
            <summary> Serialize this operator </summary>
            <param name="tw">Destination for the XML data </param>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpDifference.Naive">
            <summary>
            Naive implementation for Difference
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDifference.Naive.FnStepLeft">
            <summary>Step functionality for difference</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDifference.Naive.FnStepRight">
            <summary>Step functionality for difference</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDifference.Naive.FnKeepLeft">
            <summary>Keep functionality for difference</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDifference.Naive.FnKeepRight">
            <summary>Keep functionality for difference</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDifference.Naive.FnPassRight">
            <summary>Pass functionality for difference</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDifference.Naive.FnPropRight">
            <summary>Prop functionality for difference</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDifference.Naive.FnFinalLeft">
            <summary>Final functionality for difference</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDifference.Naive.FnFinalRight">
            <summary>Final functionality for difference</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDifference.Naive.StateSize">
            <summary> How many data items are curently held in state </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpJoin">
            <summary>
            Base Join class.  Has no functionality on its own.
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpJoin.XMLEXPR">
            <summary> XML Attribute name for join expression </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.#ctor">
            <summary>
            Default Constructor for OpJoin
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.#ctor(System.String,WhitStream.QueryEngine.Query,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for a Join operator
            </summary>
            <param name="pred">The predicate defining the join</param>
            <param name="opL">The left input query operator</param>
            <param name="opR">The right input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.Predicate">
            <summary>
            Property to get and set the join predicate
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SerializeOp(System.IO.TextWriter)">
            <summary> Serialize this operator </summary>
            <param name="tw">Destination for this XML data</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.Benefit(WhitStream.Data.PunctuationScheme)">
            <summary>
            Determines if the given Punctuation sheme benefits Join
            </summary>
            <param name="ps">The punctuation scheme to check</param>
            <returns>If Benefits = true, else false</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.Benefit(WhitStream.Data.PunctuationScheme,System.Int32[])">
            <summary>
            Determines if the given Punctuation sheme benefits Group-by
            </summary>
            <param name="ps">The punctuation scheme to check</param>
            <param name="attrs">The int[] to check</param>
            <returns>If Benefits = true, else false</returns>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash">
            <summary>
            Models the query operator Join using the pipelined double-hash join algorithm
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash.#ctor(System.String)">
            <summary>
            Constructor for a new Join object, given some predicate and data sources
            </summary>
            <param name="pred">The predicate to filter on</param>
            <remarks>The predicate accepts =, !=, &lt;,&gt;, &lt;=, &gt;=, AND, OR, and NOT.</remarks>
            <remarks>To compare with attributes in a data item, you first give '$', followed
            by the DataItem number (always '1' or '2' for join), and then the attribute number (1-based)</remarks>
            <example>"$1.4 = $2.1" finds all data items that match on the fourth attribute equals the first attribute</example>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash.StateSize">
            <summary> How many data items are curently held in state </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash.FnStepListLeft">
            <summary>StepList functionality for symmetric hash join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash.FnStepListRight">
            <summary>StepList functionality for symmetric hash join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash.FnKeepLeft">
            <summary>Keep functionality for symmetric hash join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash.FnKeepRight">
            <summary>Keep functionality for symmetric hash join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash.FnPropLeft">
            <summary>Prop functionality for symmetric hash join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash.FnPropRight">
            <summary>Prop functionality for symmetric hash join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash.FnFinalLeft">
            <summary>Final functionality for symmetric hash join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash.FnFinalRight">
            <summary>Final functionality for symmetric hash join</summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash.GetAttribute(System.String,System.Int32,System.Int32@,System.Int32@)">
            Find the join attributes for the appropriate input
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash.JFinalLeft(System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Final functionality for Join -- clear out the right input
            </summary>
            <param name="ldi">Always unchanged</param>
            <seealso cref="T:WhitStream.QueryEngine.Final"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmetricHash.JFinalRight(System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Final functionality for Join -- clear out the left input
            </summary>
            <param name="ldi">Always unchanged</param>
            <seealso cref="T:WhitStream.QueryEngine.Final"/>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin">
            <summary>
            Models the query operator Join using the sort-merge join algorithm
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.lLeft">
            DataItem objects from the left input
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.lRight">
            DataItem objects from the right input
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.orderLeft">
            Since merge needs order - store which value of the dataitem is sorted
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.orderRight">
            Since merge needs order - store which value of the dataitem is sorted
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.#ctor">
            <summary>
            Default constructor for OpJoinMerge
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.#ctor(System.String)">
            <summary>
            Constructor for a new Join object, given some predicate and data sources
            </summary>
            <param name="pred">The predicate to filter on</param>
            <remarks>The predicate accepts =, !=, &lt;,&gt;, &lt;=, &gt;=, AND, OR, and NOT.</remarks>
            <remarks>To compare with attributes in a data item, you first give '$', followed
            by the DataItem number (always '1' or '2' for join), and then the attribute number (1-based)</remarks>
            <example>"$1.4 = $2.1" finds all data items that match on the fourth attribute equals the first attribute</example>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.StateSize">
            <summary> How many data items are curently held in state </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.FnStepLeft">
            <summary>Step functionality for merge join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.FnStepRight">
            <summary>Step functionality for merge join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.FnStepListLeft">
            <summary>StepList functionality for merge join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.FnStepListRight">
            <summary>StepList functionality for merge join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.FnKeepLeft">
            <summary>Keep functionality for merge join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.FnKeepRight">
            <summary>Keep functionality for merge join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.FnPropLeft">
            <summary>Prop functionality for merge join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.FnPropRight">
            <summary>Prop functionality for merge join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.FnFinalLeft">
            <summary>Final functionality for merge join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.FnFinalRight">
            <summary>Final functionality for merge join</summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.MergeJoin.FindJoinAttributes(System.String)">
            <summary>
            Find the attributes that are participating in this join
            </summary>
            <param name="pred">The predicate for this join</param>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct">
            <summary>
             Models the pipelined double-hash join algorithm, with an enhancement for punctuations. The
              standard symmetric hash join algorithm works well for equality searches, and therefore
              also for equality punctuation matches, so punctuations with literal and list patterns
              on the join attributes work well. However, those kinds of punctuations take up much more
              bandwidth and require many more match calls than a range punctuation will. This algorithm
              must know a priori the incoming punctuation scheme. If the punctuations are range punctuations,
              then a hash table of hash tables is created for each input. Each nested hash table is created
              for data items that fall into one specific punctuation range. When the range punctuation
              arrives, the entire hash table can be removed, rather than individual data items. The hash key
              for the outer hash table for data items is computed using a punctuation with the range for that
              data item.
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.#ctor">
            <summary>
            Default constructor for OpJoinSymmRangePattern
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Constructor for a new Join object, given some predicate and data sources
            </summary>
            <param name="pred">The predicate to filter on</param>
            <param name="iLeftRangePattern">Which attribute on the left input will be the range pattern</param> 
            <param name="iRightRangePattern">Which attribute on the right input will be the range pattern</param>
            <remarks>The predicate accepts =, !=, &lt;,&gt;, &lt;=, &gt;=, AND, OR, and NOT.</remarks>
            <remarks>To compare with attributes in a data item, you first give '$', followed
            by the DataItem number (always '1' or '2' for join), and then the attribute number (1-based)</remarks>
            <example>"$1.4 = $2.1" finds all data items that match on the fourth attribute equals the first attribute</example>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.LeftRangeAttribute">
            <summary>
            Property to get and set the attribute for the range pattern for the left input
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.RightRangeAttribute">
            <summary>
            Property to get and set the attribute for the range pattern for the right input
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.FnStepListLeft">
            <summary>StepList functionality for symmetric hash/punct join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.FnStepListRight">
            <summary>StepList functionality for symmetric hash/punct join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.FnPassLeft">
            <summary>Pass functionality for symmetric hash/punct join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.FnPassRight">
            <summary>Pass functionality for symmetric hash/punct join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.FnKeepLeft">
            <summary>Keep functionality for symmetric hash/punct join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.FnKeepRight">
            <summary>Keep functionality for symmetric hash/punct join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.FnPropLeft">
            <summary>Prop functionality for symmetric hash/punct join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.FnPropRight">
            <summary>Prop functionality for symmetric hash/punct join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.FnFinalLeft">
            <summary>Final functionality for symmetric hash/punct join</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.FnFinalRight">
            <summary>Final functionality for symmetric hash/punct join</summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.FindJoinAttributes(System.String)">
            <summary>
            Find the attributes that are participating in this join
            </summary>
            <param name="pred">The predicate for this join</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.GetAttribute(System.String,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Find the join attributes for the appropriate input
            </summary>
            <param name="pred">The predicate for this join</param>
            <param name="i">The current location to look at in the predicate</param>
            <param name="l">The setting if this attribute is for the left input</param>
            <param name="r">The setting if this attribute is for the right input</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.JStepListLeft(System.Collections.Generic.List{WhitStream.Data.DataItem},System.Collections.Generic.List{WhitStream.Data.DataItem}@,System.Boolean@)">
            <summary>
            Step functionality for Join -- output all matches from the right input
            </summary>
            <param name="rgdi">The input DataItems</param>
            <param name="ldi">The result data items to be output</param>
            <param name="eofInput">Whether we've hit EOF</param>
            <seealso cref="T:WhitStream.QueryEngine.Step"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.JStepListRight(System.Collections.Generic.List{WhitStream.Data.DataItem},System.Collections.Generic.List{WhitStream.Data.DataItem}@,System.Boolean@)">
            <summary>
            Step functionality for Join -- output all matches from the left input
            </summary>
            <param name="rgdi">The input DataItems</param>
            <param name="ldi">The resulting data items to be output</param>
            <param name="eofInput">Whether we've hit EOF</param>
            <seealso cref="T:WhitStream.QueryEngine.Step"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.JFinalLeft(System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Final functionality for Join -- clear out all hash tables on the right side
            </summary>
            <param name="ldi">Any final output data (always empty)</param>
            <seealso cref="T:WhitStream.QueryEngine.Final"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.JFinalRight(System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Final functionality for Join -- clear out all hash tables on the left side
            </summary>
            <param name="ldi">Any final output data (always empty)</param>
            <seealso cref="T:WhitStream.QueryEngine.Final"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.JPassLeft(WhitStream.Data.Punctuation,System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Pass functionality for join : output results when first punctuation arrives (as per step)
            </summary>
            <param name="p">The input punctuation</param>
            <param name="ldi">Output data items</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.JPassRight(WhitStream.Data.Punctuation,System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Pass functionality for join : output results when first punctuation arrives (as per step)
            </summary>
            <param name="p">The input punctuation</param>
            <param name="ldi">Output data items</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.JKeepLeft(WhitStream.Data.Punctuation)">
            <summary>
            Keep functionality for Join -- clear out all stored data from the right that matches this punctuation 
            </summary>
            <param name="p">The punctuation to match</param>
            <seealso cref="T:WhitStream.QueryEngine.Keep"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.JKeepRight(WhitStream.Data.Punctuation)">
            <summary>
            Keep functionality for Join -- clear out all stored data from the left that matches this punctuation 
            </summary>
            <param name="p">The punctuation to match</param>
            <seealso cref="T:WhitStream.QueryEngine.Keep"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.JPropLeft(WhitStream.Data.Punctuation,System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Propagate functionality for Join -- output any joined punctuations 
            </summary>
            <param name="p">The punctuation to match from the left</param>
            <param name="ldi">Any output punctuations</param>
            <seealso cref="T:WhitStream.QueryEngine.Prop"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpJoin.SymmRangePunct.JPropRight(WhitStream.Data.Punctuation,System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Propagate functionality for Join -- output any joined punctuations 
            </summary>
            <param name="p">The punctuation to match from the right</param>
            <param name="ldi">Any output punctuations</param>
            <seealso cref="T:WhitStream.QueryEngine.Prop"/>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.Connection">
            <summary>
            Holds connection specifications for the server to communicate
            with the source.
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.Connection.m_ConnectionName">
            <summary>
            Name of the connection if known
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.Connection.m_connectionID">
            <summary>
            Identification number for the connection (assigned its port #)
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.#ctor(System.Net.IPAddress,System.Int32,System.String)">
            <summary>
            Constructor to create the list of connects and create
            a new thread to wait/accept new connections
            </summary>
            <param name="host">The host IPAddress</param>
            <param name="port">The port to listen on</param>
            <param name="name">The name of the connection</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.Terminate">
            <summary>
            Terminates the connection
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.SerializeOp(System.IO.TextWriter)">
            <summary>
            Serialize the Generator operator by writing its row count and punctuation style
            </summary>
            <param name="tw"> The destination for writing </param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.ToString">
            <summary>
            Overide for tostring for the connection class
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.Connection.NetStream">
            <summary>
            Get the network stream
            </summary>
            <returns>The netstream for the connection</returns>
            <remarks>Only to be used by the check connection thread</remarks>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.Connection.LocalSocket">
            <summary>
            Get the local socket
            </summary>
            <returns>The socket for the connection</returns>
            <remarks>Only to be used by the check connection thread</remarks>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.Connection.Name">
            <summary>
            Get the name of the connection
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.Connection.Schema">
            <summary>
            Gets the Schema for the Connection
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.Connection.ID">
            <summary>
            Get the ID of the connection
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.Connection.m_ConnectionStarted">
            <summary>
            Whether the connection has been started by the server
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.Connection.m_sendPunctuations">
            <summary>
            Whether we have told the sources what punctuations we need
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.StartThreads">
            <summary>
            Starts the write/read threads so that connection is sending data to
            the query engine
            </summary>
            <remarks>Returns a non-zero if an error occured</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.StartRead">
            <summary>
            Sends a message to the client to start sending data
            </summary>
            <remarks>Returns a non-zero if an error occured</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.Activate">
            <summary>
            Let this operator know that it has been activated
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.Deactivate">
            <summary>
            Let this operator know that it has been deactivated
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.HandlePunctuation_Byte(WhitStream.Utility.CyclicQueue)">
            <summary>
            Handles incoming punctuations from a byte[]
            </summary>
            <param name="data">The data of the punctuation</param>
            <returns>The punctuation to add to the buffer</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.HandlePunctuation_String(WhitStream.Utility.CyclicQueue)">
            <summary>
            Handles incoming punctuations from a literal string
            </summary>
            <param name="data">The data of the punctuation</param>
            <returns>The punctuation to add to the buffer</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.HandlePunctuation_Predefined(System.Byte[])">
            <summary>
            Handles incoming punctuations from a predfined punctuation
            </summary>
            <param name="data">The data of the punctuation</param>
            <returns>The punctuation to add to the buffer</returns>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.Connection.m_readLock">
            <summary>
            Determines if it is safe to read
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.Read">
            <summary>
            Function for the read thread
            </summary>
            <remarks>Uses a cyclic buffer to store data.</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.WriteThread">
            <summary>
            Function for the write thread
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.Connection.m_packetSchema">
            <summary>
            How the "packet" looks when received
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.ParseSchema">
            <summary>
            Parses a the schema for the connection sent by the source
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Connection.Iterate(WhitStream.Utility.DataItemPool.GetDataItem,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Output new data items
            </summary>
            <remarks>Uses the cyclical buffer.</remarks>
            <returns>The DataItem objects to output</returns>
            <seealso cref="T:WhitStream.Data.DataItem"/>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpNUnion">
            <summary>
            Models the query operator Union
            </summary>
            <remarks>Since this operator is non-blocking, it uses the trivial final function</remarks>
            <seealso cref="M:WhitStream.QueryEngine.Query.FinalTrivial(System.Collections.Generic.List{WhitStream.Data.DataItem})"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpNUnion.#ctor">
            <summary>
            Default constructor for Union
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpNUnion.#ctor(WhitStream.QueryEngine.Query[])">
            <summary> Constructor for Union </summary>
            <param name="ops">The input query operators</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpNUnion.#ctor(System.String,WhitStream.QueryEngine.Query[])">
            <summary> Constructor for Union </summary>
            <param name="id">ID for this operator</param>
            <param name="ops">The input query operators</param>
            <remarks>Should only be used with deserialization</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpNUnion.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpNUnion.SerializeOp(System.IO.TextWriter)">
            <summary> Serialize this Union operator </summary>
            <param name="tw">Destination for XML data</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpNUnion.UStep(WhitStream.Data.DataItem,System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Step functionality for Union -- when a DataItem arrives, output it
            </summary>
            <param name="di">The input DataItem</param>
            <param name="ldi">The DataItem that was input</param>
            <seealso cref="T:WhitStream.QueryEngine.Step"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpNUnion.UStepList(System.Collections.Generic.List{WhitStream.Data.DataItem},System.Collections.Generic.List{WhitStream.Data.DataItem}@,System.Boolean@)">
            <summary>
            StepList functionality for Union -- when a DataItem arrives, output it
            </summary>
            <param name="rgdi">The input DataItem</param>
            <param name="ldi">The DataItem that was input</param>
            <param name="eofInput">Whether we've hit eof</param>
            <seealso cref="T:WhitStream.QueryEngine.Step"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpNUnion.UProp(WhitStream.Data.Punctuation,System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Propagation functionality for inputs of union
            </summary>
            <param name="p">Punctuation from the input</param>
            <param name="ldi">Any punctuations that can be output</param>
            <seealso cref="T:WhitStream.QueryEngine.Prop"/>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpEddy">
            <summary>
            Models the query operator Eddy
            </summary>
            <remarks>Since this operator is non-blocking, it uses the trivial final function</remarks>
            <seealso cref="M:WhitStream.QueryEngine.Query.FinalTrivial(System.Collections.Generic.List{WhitStream.Data.DataItem})"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpEddy.#ctor">
            <summary>
            Default constructor for Eddy
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpEddy.#ctor(System.Collections.Generic.List{WhitStream.QueryEngine.Query},WhitStream.QueryEngine.Query[])">
            <summary> Constructor for Eddy </summary>
            <param name="opParticipants">The operators participating in the eddy</param>
            <param name="ops">The input query operators</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpEddy.#ctor(System.String,System.Collections.Generic.List{WhitStream.QueryEngine.Query},WhitStream.QueryEngine.Query[])">
            <summary> Constructor for Eddy </summary>
            <param name="id">ID for this operator</param>
            <param name="opParticipants">The operators participating in the eddy</param>
            <param name="ops">The input query operators</param>
            <remarks>Should only be used with deserialization</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpEddy.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpEddy.SerializeOp(System.IO.TextWriter)">
            <summary> Serialize this Eddy operator </summary>
            <param name="tw">Destination for XML data</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpEddy.EStepList(System.Collections.Generic.List{WhitStream.Data.DataItem},System.Collections.Generic.List{WhitStream.Data.DataItem}@,System.Boolean@)">
            <summary>
            StepList functionality for Eddy
            </summary>
            <param name="rgdi">The input DataItem</param>
            <param name="ldi">The DataItem that was input</param>
            <param name="eofInput">Whether we've hit eof</param>
            <seealso cref="T:WhitStream.QueryEngine.Step"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpEddy.EKeep(WhitStream.Data.Punctuation)">
            <summary>
            Function to handle punctuations as they arrive in the eddy.
            In this case, we simply enqueue the punctuation as if it were
            a data item, and the Iterate function for each operator will
            process it appropriately
            </summary>
            <param name="p">The incoming punctuation</param>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.Box">
            <summary>
            Box up a group of operators into a single operator, using a single queue
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Box.#ctor">
            <summary>
            default Box operator constructor
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.Box.#ctor(WhitStream.QueryEngine.Query[])">
            <summary>
            Box operator constructor
            </summary>
            <param name="qInputs">The input operators</param>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGenerate">
            <summary>
            Class to generate data
            </summary>
            <remarks>This class does not take an input query operator -- It generates data</remarks>
            <remarks>This class must override Iterate(), since it has no source</remarks>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGenerate.ROWCOUNT">
            <summary> XML serialization constants </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGenerate.#ctor(System.Int32)">
            <summary>
            Constructor to determine how much data to generate
            </summary>
            <param name="c">The number of data items to generate</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGenerate.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor to determine how much data to generate
            </summary>
            <param name="c">The number of data items to generate</param>
            <param name="iP">The attribute to punctuate</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGenerate.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGenerate.RowCount">
            <summary>
            How many rows should this OpGenerate produce?
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGenerate.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructor to determine how much data to generate
            </summary>
            <param name="id">operator ID</param>
            <param name="rowcount">How many rows from this operator</param>
            <param name="punct">What kinds of punctuations to embed</param>
            <remarks> To be used by deserialization only </remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGenerate.SerializeOp(System.IO.TextWriter)">
            <summary>
            Serialize the Generator operator by writing its row count and punctuation style
            </summary>
            <param name="tw"> The destination for writing </param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGenerate.Iterate(WhitStream.Utility.DataItemPool.GetDataItem,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Output new data items
            </summary>
            <returns>The DataItem objects to output</returns>
            <seealso cref="T:WhitStream.Data.DataItem"/>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGenerate.DataCount">
            <summary> Return current data rate for this stream source </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGenerate.DataRate">
            <summary> Return the data rate of this source </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGenerate.DataBacklog">
            <summary> How many data items are waiting to be processed? </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpServer">
            <summary>
            Class to receieve data from a network stream
            </summary>
            <remarks>This class does not take an input query operator -- It generates data</remarks>
            <remarks>This class must override Iterate(), since it's source is outside WhitStream</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServer.#ctor">
            <summary> Default constructor to set up this operator as a listener </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServer.#ctor(System.Int32)">
            <summary>
            Constructor set this operator up as a listener on a specific port
            </summary>
            <param name="port">The port to listen on</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServer.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServer.SetClient(System.Net.Sockets.NetworkStream)">
            <summary> Method to start listening to a network stream input </summary>
            <param name="ns">The network stream to listen on</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServer.StrReader">
            <summary> Read data from the stream as quickly as possible, and store it in a queue </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServer.GetItemsReady">
            <summary>
            Finds the number of tuples ready from this operator
            </summary>
            <returns>The number of items ready to be processed</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServer.Iterate(WhitStream.Utility.DataItemPool.GetDataItem,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Output new data items
            </summary>
            <returns>The DataItem objects to output</returns>
            <seealso cref="T:WhitStream.Data.DataItem"/>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpServer.DataCount">
            <summary> Return current data rate for this stream source </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpServer.DataRate">
            <summary> Return the data rate of this source </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpServer.DataBacklog">
            <summary> How many data items are waiting to be processed? </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpServerRaw">
            <summary>
            Class to receieve data from a network stream in raw form
            </summary>
            <remarks>This class does not take an input query operator -- It generates data</remarks>
            <remarks>This class must override Iterate(), since it's source is outside WhitStream</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServerRaw.#ctor">
            <summary> Default constructor to set up this operator as a listener </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServerRaw.#ctor(System.Int32)">
            <summary>
            Constructor set this operator up as a listener on a specific port
            </summary>
            <param name="port">The port to listen on</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServerRaw.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServerRaw.SetClient(System.Net.Sockets.NetworkStream)">
            <summary> Method to start listening to a network stream input </summary>
            <param name="ns">The network stream to listen on</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServerRaw.StrReader">
            <summary> Read data from the stream as quickly as possible, and store it in a queue </summary>
            <remarks> Will recieve the header file before it tries to read raw data</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServerRaw.GetItemsReady">
            <summary>
            Finds the number of tuples ready from this operator
            </summary>
            <returns>The number of items ready to be processed</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpServerRaw.Iterate(WhitStream.Utility.DataItemPool.GetDataItem,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Output new data items
            </summary>
            <returns>The DataItem objects to output</returns>
            <seealso cref="T:WhitStream.Data.DataItem"/>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpServerRaw.DataCount">
            <summary> Return the current number of data items produced by this stream source </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpServerRaw.DataRate">
            <summary> Return the data rate of this source </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpServerRaw.DataBacklog">
            <summary> How many data items are waiting to be processed? </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpQueue">
            <summary>
            Operator to model a queue
            Data is pulled from the queue using Iterate
            Data is pushed into the queue using Push (not a member of UnaryOp!)
            </summary>
            <remarks>Since the queue does not read from its children, it is
            not appropriate for pull-based queries. It should only be used
            with the multi-threaded scheduler.
            </remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpQueue.#ctor">
            <summary>
            Default constructor for Queue
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpQueue.#ctor(System.Int32)">
            <summary>
            Constructor for setting max data output size for Queue
            </summary>
            <param name="m">Maximum data items to output</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpQueue.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpQueue.SerializeOp(System.IO.TextWriter)">
            <summary>
            Serialize this Queue operator
            </summary>
            <remarks>
            Actually, the scheduler should handle this, so
            serialization of this operator is unnecessary
            </remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpQueue.GetItemsReady">
            <summary>
            Finds the number of tuples ready from this operator
            </summary>
            <returns>The number of items ready to be processed</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpQueue.Iterate(WhitStream.Utility.DataItemPool.GetDataItem,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Iterate through input data items. For a queue, just 
            output up to maximum data items
            </summary>
            <returns></returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpQueue.Push(WhitStream.Data.DataItem)">
            <summary> Add a data item to the queue </summary>
            <param name="d">Data to enqueue</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpQueue.Push(System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary> Add a list of data items to the queue </summary>
            <param name="ds">Data to enqueue</param>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpQueue.HasEOF">
            <summary>
            Return whether EOF is in the queue or not
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpQueue.DataCount">
            <summary>
            Return how much data is in the queue
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpQueue.PunctCount">
            <summary>
            Return how many punctuations are in the queue
            </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpSelect">
            <summary>
            Operator to model the query operator Select.
            Filter out DataItem objects based on a given predicate.
            </summary>
            <remarks>Since Select is non-blocking, it uses the trivial Final function </remarks>
            <seealso cref="M:WhitStream.QueryEngine.Query.FinalTrivial(System.Collections.Generic.List{WhitStream.Data.DataItem})"/>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpSelect.XMLEXPR">
            <summary> Constant for serialization to XML </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpSelect.#ctor">
            <summary>
            Default constructor for OpSelect
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpSelect.#ctor(System.String,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for a new Select object, given some predicate and data source
            </summary>
            <param name="pred">The predicate to filter on</param>
            <param name="opIn">The input query operator</param>
            <remarks>The predicate accepts =, !=, &lt;,&gt;, &lt;=, &gt;=, AND, OR, and NOT.</remarks>
            <remarks>To compare with attributes in a data item, you first give '$', followed
            by the DataItem number (always '1' for select), and then the attribute number (1-based)</remarks>
            <example>"$1.4 = 100" finds all data items with the value 100 in the fourth attribute</example>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpSelect.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpSelect.#ctor(System.String,System.String,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor to build select operator from XML
            </summary>
            <param name="id">ID for this operator</param>
            <param name="pred">Predicate for this operator</param>
            <param name="opIn">Input for this operator</param>
            <remarks>To be used by deserialization only</remarks>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpSelect.Predicate">
            <summary>
            The selection predicate to evaluate over each data item as it arrives
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpSelect.SerializeOp(System.IO.TextWriter)">
            <summary> Serialize this Select operator by writing the expression </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpSelect.Naive">
            <summary>
            Naive select algorithm -- simply apply predicate to each data item as they arrive
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpSelect.Naive.#ctor(System.String)">
            <summary>
            Constructor for a naive select implementation
            </summary>
            <param name="pred">The string expression for select</param>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpSelect.Naive.FnStep">
            <summary>Step functionality for Select</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpSelect.Naive.FnStepList">
            <summary>StepList functionality for Select</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpSelect.Naive.FnProp">
            <summary>Prop functionality for Select</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpSelect.RandomDrop">
            <summary>
            RandomDrop select algorithm -- apply predicate to each data item as they arrive,
            and also randomly select data items to drop for load shedding
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpSelect.RandomDrop.#ctor(System.String,System.Int32)">
            <summary>
            Constructor for a naive select implementation
            </summary>
            <param name="pred">The string expression for select</param>
            <param name="frequency">How often should a data item be dropped (1 data item per <code>frequency</code>)?</param>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpSelect.RandomDrop.FnStep">
            <summary>Step functionality for Select (with random drop)</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpSelect.RandomDrop.FnStepList">
            <summary>StepList functionality for Select (with random drop)</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpSelect.RandomDrop.FnProp">
            <summary>Prop functionality for Select (with random drop)</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpProject">
            <summary>
            Models the query operator Project, to map DataItem objects from one format to another
            </summary>
            <remarks>Since Project is non-blocking, it uses the trivial Final function </remarks>
            <seealso cref="M:WhitStream.QueryEngine.Query.FinalTrivial(System.Collections.Generic.List{WhitStream.Data.DataItem})"/>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpProject.XMLATTRS">
            <summary>
            The function to modify the format of each arriving DataItem
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpProject.#ctor">
            <summary>
            Default constructor for project
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpProject.#ctor(WhitStream.QueryEngine.UnaryOp.Map,System.Int32[],WhitStream.QueryEngine.Query)">
            <summary>
            The constructor for Project, given a format function and the source
            </summary>
            <param name="m">The function to map the format of each DataItem</param>
            <param name="a">The attributes that remain after projection</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpProject.#ctor(System.String,System.String,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor to build project operator from XML
            To be used by deserialization only
            </summary>
            <param name="id">ID for this operator</param>
            <param name="sAttr">Attributes to project</param>
            <param name="opIn">Input operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpProject.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpProject.Attributes">
            <summary>
            What attributes are we projecting?
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpProject.SerializeOp(System.IO.TextWriter)">
            <summary> Serialize this Project operator </summary>
            <param name="tw"> Destination for XML data </param>
            <TODO>Need to figure out a way to serialize Map functions</TODO>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpProject.Naive">
            <summary>
            Naive implementation of Project (duplicate-preserving)
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpProject.Naive.#ctor(WhitStream.QueryEngine.UnaryOp.Map,System.Int32[])">
            <summary>
            Constructor for naive project implementation
            </summary>
            <param name="m">Map function (if required)</param>
            <param name="a">Attributes to project on</param>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpProject.Naive.FnStep">
            <summary>Step functionality for Project</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpProject.Naive.FnStepList">
            <summary>StepList functionality for Project</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpProject.Naive.FnProp">
            <summary>Prop functionality for Project</summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpProject.Naive.mapGeneric(WhitStream.Data.DataItem)">
            <summary>
            Generic Map function that outputs results based on given attribute list
            </summary>
            <returns>Projected data item</returns>
            <seealso cref="T:WhitStream.QueryEngine.UnaryOp.Map"/>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpProject.Benefit(WhitStream.Data.PunctuationScheme)">
            <summary>
            Determines if the given Punctuation scheme benefits Project
            </summary>
            <param name="ps">The punctuation scheme to check</param>
            <returns>If Benefits = true, else false</returns>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpDupElim">
            <summary>
            Models the query operator DuplicateElimination, to remove duplicates from the input
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpDupElim.#ctor">
            <summary>
            Default constructor for OpDupElim
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpDupElim.#ctor(WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for DupElim, given only an input
            </summary>
            <param name="opIn">Input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpDupElim.#ctor(System.String,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor to build dupelim operator from XML
            </summary>
            <param name="id">id for this operator</param>
            <param name="opIn">input operator</param>
            <remarks>To be used by deserialization only</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpDupElim.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpDupElim.SerializeOp(System.IO.TextWriter)">
            <summary>
            Serialize this operator
            </summary>
            <param name="tw">Destination for XML data</param>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpDupElim.HashAlgorithm">
            <summary>
            Algorithm for Duplicate Elimination using a hash table
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDupElim.HashAlgorithm.StateSize">
            <summary> How many data items are curently held in state </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDupElim.HashAlgorithm.FnStep">
            <summary>Step functionality for Duplicate Elimination</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDupElim.HashAlgorithm.FnStepList">
            <summary> StepList functionality for Duplicate Elimination </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDupElim.HashAlgorithm.FnProp">
            <summary>Prop functionality for Duplicate Elimination</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDupElim.HashAlgorithm.FnKeep">
            <summary>Keep functionality for Duplicate Elimination</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpDupElim.HashAlgorithm.FnFinal">
            <summary>Final functionality for Duplicate Elimination</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupBy">
            <summary>
            Models the query operator GroupBy, to group DataItems based on some attribute(s)
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.attrs">
            <summary>List of attributes for grouping</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.mainAttrs">
            <summary>List of attributes that will receive punctuations</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.listAttr">
            <summary>The attribute which contains a list</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.algoHash">
            <summary> The algorithm to execute </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBy.#ctor">
            <summary>
            The default constructor
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBy.#ctor(System.Int32[],WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for GroupBy.
            </summary>
            <param name="a">The attributes to group on</param>
            <param name="opIn">The input query operator</param>
            <remarks>Step functionality is determined by the aggregate child class (e.g. AVG)</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBy.#ctor(System.Int32[],System.Int32[],WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for GroupBy with main attributes
            </summary>
            <param name="a">The attributes to group on</param>
            <param name="m">The main attributes which will receive punctuations</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBy.#ctor(System.Int32[],System.Int32[],System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for GroupBy with a list attribute
            </summary>
            <param name="a">The attributes to group on</param>
            <param name="m">The main attributes which will receive punctuations</param>
            <param name="l">The attribute with a list</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBy.#ctor(System.String,System.String,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor to build GroupBy operators from XML
            </summary>
            <param name="id">ID for this operator</param>
            <param name="a">Attributes for grouping</param>
            <param name="opIn">Input operator</param>
            <remarks> To be used by deserialization only </remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBy.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGroupBy.GroupingAttributes">
            <summary>
            The attributes to group by
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBy.SerializeOp(System.IO.TextWriter)">
            <summary> Serialize this group-by operator </summary>
            <param name="tw"> Destination for XML data </param> 
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm">
            <summary>
            Generic functionality for grouping using hash tables
            </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.Group">
            <summary>Models state for the GroupBy operator</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.Group.keys">
            <summary>Which keys make up this group?</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.Group.oState">
            <summary>What state is required for continued execution for an aggregate operator (e.g. AVG)</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.Group.oResult">
            <summary>What would the result for this group be if the result was required?</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.Group.hashcode">
            <summary>What is this group's hashcode?</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.Group.sdhashcode">
            <summary>What is the hashcode for this group's SubDictionary?</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.SubDictionary">
            <summary>Dictionary class that contains context information</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.SubDictionary.subHt">
            <summary></summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.SubDictionary.keys">
            <summary>What are the keys for this SubDictionary?</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.SubDictionary.hashcode">
            <summary>What is this SubDictionary's hashcode?</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.attrs">
            <summary>Which attributes are we grouping on?</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.mainAttrs">
            <summary>Which attributes are we </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.#ctor(System.Int32[])">
            <summary>
            Create a new HashAlgorithm operator
            </summary>
            <param name="a">The attributes for grouping</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.#ctor(System.Int32[],System.Int32[])">
            <summary>
            Create a new HashAlgorithm operator
            </summary>
            <param name="a">The attributes for grouping</param>
            <param name="m">The main attributes to group on</param>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.StateSize">
            <summary> How many data items are curently held in state </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.FnStepList">
            <summary>Generic StepList functionality for Group By</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.FnFinal">
            <summary>Generic Final functionality for Group By</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.FnPass">
            <summary>Generic Pass functionality for Group By</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.FnKeep">
            <summary>Generic Keep functionality for Group By</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.FnProp">
            <summary>Generic Prop functionality for Group By</summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.FindGroup(WhitStream.Data.DataItem,WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.Group@)">
            <summary>
            Find the appropriate group for this DataItem object
            </summary>
            <param name="di">The input DataItem</param>
            <param name="g">The group that the DataItem belongs to</param>
            <returns>True if this group already exists, false if this is a new group</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBy.HashAlgorithm.FindMatchingGroups(WhitStream.Data.Punctuation)">
            <summary>
            Return all groups that match the given punctuation
            </summary>
            <param name="p">The punctuation to match groups on</param>
            <returns>The groups that match the punctuation</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBy.Benefit(WhitStream.Data.PunctuationScheme)">
            <summary>
            Determines if the given Punctuation scheme benefits Group-by 
            </summary>
            <param name="ps">The punctuation scheme to check</param>
            <returns>If Benefits = true, else false</returns>
            <remarks>Main attributes not yet supported</remarks>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupByCount">
            <summary>
            Operator to count DataItem objects based on some attributes
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByCount.#ctor(System.Int32[],WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Count
            </summary>
            <param name="attrs">Which attributes to group on</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByCount.#ctor(System.Int32[],System.Int32[],WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Count with main attribute support
            </summary>
            <param name="attrs">The attributes to group on</param>
            <param name="mainAttrs">The attributes which will recieve punctuation</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByCount.#ctor(System.Int32[],System.Int32[],System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Count with a list attribute
            </summary>
            <param name="attrs">The attributes to group on</param>
            <param name="mainAttrs">The attributes which will recieve punctuation</param>
            <param name="listAttr">The attribute which contians a list</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByCount.SerializeOp(System.IO.TextWriter)">
            <summary>
            Serialize this group-by operator
            </summary>
            <param name="tw">Destination for XML data</param>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupByCount.HashAlgorithmCount">
            <summary>Specific Count functionality</summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByCount.HashAlgorithmCount.#ctor(System.Int32[],System.Int32[],System.Int32)">
            <summary>Constructor for Group by-Count</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGroupByCount.HashAlgorithmCount.FnStep">
            <summary>Step functionality for Group By-Count</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupBySum">
            <summary>
            Operator to sum attributes of DataItem objects based on some attributes
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBySum.#ctor(System.Int32[],System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Sum
            </summary>
            <param name="attrs">Which attributes to group on</param>
            <param name="v">Which attribute to sum over</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBySum.#ctor(System.Int32[],System.Int32[],System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Sum with main attribute support
            </summary>
            <param name="attrs">The attributes to group on</param>
            <param name="mainAttrs">The attributes which will recieve punctuation</param>
            <param name="v">Which attribute to sum over</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBySum.#ctor(System.Int32[],System.Int32[],System.Int32,System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Sum with main attribute support
            </summary>
            <param name="attrs">The attributes to group on</param>
            <param name="mainAttrs">The attributes which will recieve punctuation</param>
            <param name="v">Which attribute to sum over</param>
            <param name="listAttr">The attribute which contains a list</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBySum.#ctor(System.String,System.String,System.String,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Sum
            </summary>
            <param name="id">The ID for this operator</param>
            <param name="a">Which attributes to group on</param>
            <param name="v">Attribute to sum</param>
            <param name="opIn">The input query operator</param>
            <remarks> This constructor should only be called through deserialization</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBySum.SerializeOp(System.IO.TextWriter)">
            <summary>
            Serialize this Sum operator
            </summary>
            <param name="tw">Destination for XML data</param>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupBySum.HashAlgorithmSum">
            <summary>Algorithm for grouo-by/sum</summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupBySum.HashAlgorithmSum.#ctor(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Constructor for group-by/sum
            </summary>
            <param name="a">Attributes for grouping</param>
            <param name="m">Main attributes for grouping</param>
            <param name="v">Initial value for sum</param>
            <param name="l">Attribute that contains a list</param>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGroupBySum.HashAlgorithmSum.FnStep">
            <summary>Step functionality for group-by/sum</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupByAvg">
            <summary>
            Operator to average attributes of DataItem objects based on some attributes
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupByAvg.val">
            <summary>
            The attribute to keep average over
            </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupByAvg.State">
            <summary>
            Specific state for AVG -- track the count and sume for each group
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupByAvg.State.sum">
            <summary>
            Specific state variables for tracking the average
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupByAvg.State.count">
            <summary>
            Specific state variables for tracking the average
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByAvg.#ctor(System.Int32[],System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Average
            </summary>
            <param name="attrs">Which attributes to group on</param>
            <param name="v">Which attribute to average over</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByAvg.#ctor(System.Int32[],System.Int32[],System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Average with main attribute support
            </summary>
            <param name="attrs">Which attributes to group on</param>
            <param name="mainAttrs">Which main attributes to group on</param>
            <param name="v">Which attribute to average over</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByAvg.#ctor(System.Int32[],System.Int32[],System.Int32,System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Average with main attribute support
            </summary>
            <param name="attrs">Which attributes to group on</param>
            <param name="mainAttrs">Which main attributes to group on</param>
            <param name="v">Which attribute to average over</param>
            <param name="listAttr">The attribute that contains a list</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByAvg.#ctor(System.String,System.String,System.String,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Average
            </summary>
            <param name="id">ID for this operator</param>
            <param name="a">Which attributes to group on</param>
            <param name="v">The attribute to average over</param>
            <param name="opIn">The input query operator</param>
            <remarks>Should only be called through deserialization</remarks> 
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByAvg.SerializeOp(System.IO.TextWriter)">
            <summary>
            Serialize this average operator
            </summary>
            <param name="tw">Destination for XML data </param>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupByAvg.HashAlgorithmAvg">
            <summary>
            Algorithm for group-by/Average
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByAvg.HashAlgorithmAvg.#ctor(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Constructor for avergae
            </summary>
            <param name="a">attributes for grouping</param>
            <param name="m">main attributes for grouping</param>
            <param name="v">initial valuefor average</param>
            <param name="l">attribute that contains a list</param>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGroupByAvg.HashAlgorithmAvg.FnStep">
            <summary>Step functionality for group-by/average</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupByMax">
            <summary>
            Operator to find the max of DataItem objects based on some attributes
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupByMax.val">
            <summary>
            Which attribute to keep max over
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByMax.#ctor(System.Int32[],System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Max
            </summary>
            <param name="attrs">Which attributes to group on</param>
            <param name="v">Which attribute to keep max over</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByMax.#ctor(System.Int32[],System.Int32[],System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Max with main attribute support
            </summary>
            <param name="attrs">The attributes to group on</param>
            <param name="mainAttrs">The attributes which will recieve punctuation</param>
            <param name="v">The attribute to max over</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByMax.#ctor(System.Int32[],System.Int32[],System.Int32,System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Max with main attribute support
            </summary>
            <param name="attrs">The attributes to group on</param>
            <param name="mainAttrs">The attributes which will recieve punctuation</param>
            <param name="v">The attribute to max over</param>
            <param name="listAttr">The attribute that contains a list</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByMax.#ctor(System.String,System.String,System.String,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Max
            </summary>
            <param name="id">ID for this operator</param>
            <param name="a">Which attributes to group on</param>
            <param name="v">Attribute to find the max of</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByMax.SerializeOp(System.IO.TextWriter)">
            <summary> Serialize this Max operator </summary>
            <param name="tw">Destination for the XML data</param>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupByMax.HashAlgorithmMax">
            <summary>
            Algorithm for group-by/max
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByMax.HashAlgorithmMax.#ctor(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Constructor for group-by/max
            </summary>
            <param name="a">attributes for grouping</param>
            <param name="m">main attributes for grouping</param>
            <param name="v">initial value</param>
            <param name="l">attribute that contains a list</param>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGroupByMax.HashAlgorithmMax.FnStep">
            <summary>Step functionality for group-by/max</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupByMin">
            <summary>
            Operator to find the minimum of DataItem objects based on some attributes
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpGroupByMin.val">
            <summary>
            Which attribute to keep minimum over
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByMin.#ctor(System.Int32[],System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Min
            </summary>
            <param name="attrs">Which attributes to group on</param>
            <param name="v">Which attribute to min over</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByMin.#ctor(System.Int32[],System.Int32[],System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Min with main attribute support
            </summary>
            <param name="attrs">The attributes to group on</param>
            <param name="mainAttrs">The attributes which will recieve punctuation</param>
            <param name="v">The attribute to keep min over</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByMin.#ctor(System.Int32[],System.Int32[],System.Int32,System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Min with main attribute support
            </summary>
            <param name="attrs">The attributes to group on</param>
            <param name="mainAttrs">The attributes which will recieve punctuation</param>
            <param name="v">The attribute to keep min over</param>
            <param name="listAttr">The attribute which contains a list</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByMin.#ctor(System.String,System.String,System.String,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Min
            </summary>
            <param name="id">ID for this operator</param>
            <param name="a">Which attributes to group on</param>
            <param name="v">Attribute to find the min of</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByMin.SerializeOp(System.IO.TextWriter)">
            <summary> Serialize this operator </summary>
            <param name="tw">Destination for the XML data</param>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpGroupByMin.HashAlgorithmMin">
            <summary>
            Algorithm for group-by/min
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpGroupByMin.HashAlgorithmMin.#ctor(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Constructor for group-by/min
            </summary>
            <param name="a">attributes for grouping</param>
            <param name="m">main attribute for grouping</param>
            <param name="v">intial value</param>
            <param name="l">attribute with a list</param>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpGroupByMin.HashAlgorithmMin.FnStep">
            <summary>Step functionality for group-by/min</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpSort">
            <summary>
            Models the query operator Sort
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpSort.#ctor(System.Collections.Generic.IComparer{WhitStream.Data.DataItem},System.Int32[],WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for the query operator Sort
            </summary>
            <param name="cmp">Object to determine how to compare two DataItem objects</param>
            <param name="a">The sorting attributes</param>
            <param name="opIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpSort.ToString">
            <summary>String containing state for this operator</summary>
            <returns>String representation of this operator, including state information</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpSort.SerializeOp(System.IO.TextWriter)">
            <summary> Serialize this operator </summary>
            <param name="tw">Destination for the XML data</param>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpSort.SortedInput">
            <summary>
            Algorithm for the Sort operator
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpSort.SortedInput.#ctor(System.Collections.Generic.IComparer{WhitStream.Data.DataItem},System.Int32[])">
            <summary>
            Constructor for sorted-input algorithm
            </summary>
            <param name="c">function to execute comparison</param>
            <param name="a">attributes to sort</param>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpSort.SortedInput.StateSize">
            <summary> How many data items are curently held in state </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpSort.SortedInput.FnStep">
            <summary>Step functionality for orderby</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpSort.SortedInput.FnPass">
            <summary>Pass functionality for orderby</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpSort.SortedInput.FnKeep">
            <summary>Keep functionality for orderby</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpSort.SortedInput.FnProp">
            <summary>Prop functionality for orderby</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpSort.SortedInput.FnFinal">
            <summary>Final functionality for orderby</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpRelation">
            <summary>
            Operator to perform a delegate method on a data item
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpRelation.#ctor(WhitStream.QueryEngine.UnaryOp.Relation,WhitStream.Database.RelationTable,WhitStream.QueryEngine.Query)">
            <summary>
            Cunstructor for a Relation operator with a relation table
            </summary>
            <param name="diRel">The relation to perform on data items</param>
            <param name="relTable">The table to use</param>
            <param name="OpIn">The input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpRelation.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpRelation.RelationAlgorithm">
            <summary>
            Data item maniputlation with access to a table
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpRelation.RelationAlgorithm.#ctor(WhitStream.QueryEngine.UnaryOp.Relation,WhitStream.Database.RelationTable)">
            <summary>
            Constructor for a relation algorithm
            </summary>
            <param name="rel">Relation for data items</param>
            <param name="relTable">The table to use</param>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpRelation.RelationAlgorithm.FnStep">
            <summary>Step functionality for DelegateOp (relation)</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpRelation.RelationAlgorithm.FnStepList">
            <summary>StepList functionality for DelegateOp (relation)</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpRelation.RelationAlgorithm.FnProp">
            <summary>Prop functionality for DelegateOp (relation)</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpRelation.RelationAlgorithm.StateSize">
            <summary>How many items are currently held in state</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpBucket">
            <summary>
            Bucket operator for attaching window ids (WIDs) to data items
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpBucket.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,WhitStream.QueryEngine.Query)">
            <summary>
            Base constructor for a Bucket operator
            </summary>
            <param name="range">The range of the window</param>
            <param name="slide">The slide of the window</param>
            <param name="windowAttr">The attribute to window over</param>
            <param name="partitionAttr">The attribute to partition over</param>
            <param name="opIn">The input query operator</param>
            <remarks>Put a -1 in for windowAttr if it is tuple based</remarks>
            <remarks>Partitioning is only available for tuple based windowing, use -1 to indicate no partitioning</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpBucket.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpBucket.Naive">
            <summary>
            Naive - assumes tuples are in order
            </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpBucket.Naive.Group">
            <summary>Maintains the state for partitioned window groups</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpBucket.Naive.Group.hashcode">
            <summary>What is this group's hashcode?</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpBucket.Naive.Group.tuplesPast">
            <summary>How many data items have passed through this group?</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.QueryOperators.OpBucket.Naive.Group.lastfirstWID">
            <summary>What was the first WID for the last data item in this group?</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpBucket.Naive.StateSize">
            <summary>What is the size of this operator's state?</summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpBucket.Naive.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor for the Naive Bucket operator algorithm
            </summary>
            <param name="range">The range of the window</param>
            <param name="slide">The slide of the window</param>
            <param name="windowAttr">The attribute to window over</param>
            <param name="partitionAttr">The attribute to partition over</param>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpBucket.Naive.FnStep">
            <summary>Step functionality for Bucket</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpBucket.Naive.FnStepList">
            <summary>StepList functionality for Bucket</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.QueryOperators.OpBucket.Naive.FnProp">
            <summary>Prop functionality for Bucket</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.QueryOperators.OpMultiplexer">
            <summary>
            Class to publish data items to multiple sources
            </summary>
            <remarks>Call the GetQuery function to get a Query that will return the results from the operator
            rather than using OpMulitplexer itself</remarks>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpMultiplexer.#ctor(WhitStream.QueryEngine.Query)">
            <summary>
            Constructor to create a multiplexing operator
            </summary>
            <param name="op">The input Query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpMultiplexer.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpMultiplexer.GetQuery">
            <summary>
            Get a query which returns data items from the Multiplexer's source
            </summary>
            <returns></returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpMultiplexer.Iterate(WhitStream.Utility.DataItemPool.GetDataItem,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Get more data items from the source and add it to all internal buffers
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpMultiplexer.DummyQuery.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpMultiplexer.DummyQuery.GetItemsReady">
            <summary>
            Finds the number of tuples ready from this operator
            </summary>
            <returns>The number of items ready to be processed</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.QueryOperators.OpMultiplexer.DummyQuery.Iterate(WhitStream.Utility.DataItemPool.GetDataItem,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Iterate function to work through data items.
            </summary>
            <returns>DataItem objects that can be output from this iteration</returns>
        </member>
        <member name="T:WhitStream.QueryEngine.Scheduler.RoundRobinScheduler">
            <summary>
            A multi-threaded scheduler for executing a query using a round-robin algorithm
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.RoundRobinScheduler.Init(System.Boolean,WhitStream.QueryEngine.Query[])">
            <summary> Initialize the scheduler to execute the given query </summary>
            <param name="breakOut">Should the query operators run in their own thread?</param>
            <param name="qs">The query plans to execute</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.RoundRobinScheduler.AddQuery(System.Boolean,WhitStream.QueryEngine.Query[])">
            <summary> Add new queries to the scheduler during execution </summary>
            <param name="breakOutOperators">Should the query operators run in their own thread?</param>
            <param name="qs">The query plans to execute</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.RoundRobinScheduler.Execute">
            <summary> Execute the query </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.RoundRobinScheduler.Complete">
            <summary> Returns true if all data sources have been read to completion </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.RoundRobinScheduler.ToString">
            <summary> String to represent this scheduler </summary>
            <returns>String to represent this scheduler</returns>
        </member>
        <member name="T:WhitStream.QueryEngine.Scheduler.GAScheduler">
            <summary>
            Scheduler algorithm using genetic programming techniques
            </summary>
            <remarks>
            Mutations can include:
                1) operator ordering
                2) Hot-swapping algorithms using C# delegates
                3) grouping/ungrouping of operators (using the NAry Box operator)
                4) number of DataItems to process in an Iterate call to a specific oeprator/group
            Crossovers must be careful to include all operators in the queries
            </remarks>
        </member>
        <member name="F:WhitStream.QueryEngine.Scheduler.GAScheduler.POPULATION">
            <summary>How many schedules to maintain at once</summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.GAScheduler.#ctor(System.Int32)">
            <summary>Constructor for Genetic Algorithm Scheduler</summary>
            <param name="i">how many items in the order</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.GAScheduler.Init(System.Boolean,WhitStream.QueryEngine.Query[])">
            <summary> Initialize the scheduler to execute the given query </summary>
            <param name="breakOut">Should the query operators run in their own thread?</param>
            <param name="qs">The query plans to execute</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.GAScheduler.AddQuery(System.Boolean,WhitStream.QueryEngine.Query[])">
            <summary> Add new queries to the scheduler during execution </summary>
            <param name="breakOutOperators">Should the query operators run in their own thread?</param>
            <param name="qs">The query plans to execute</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.GAScheduler.Execute">
            <summary> Execute the query </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.GAScheduler.Complete">
            <summary> Returns true if all data sources have been read to completion </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.GAScheduler.ToString">
            <summary> String to represent this scheduler </summary>
            <returns>String to represent this scheduler</returns>
        </member>
        <member name="T:WhitStream.QueryEngine.Scheduler.MonteCarloScheduler">
            <summary>
            A multi-threaded scheduler for executing a query using a round-robin algorithm
            </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.Scheduler.MonteCarloScheduler.MCPoints">
            <summary> Points calculator for specific operator </summary>
            <param name="iOp">The operator to calculate</param>
            <returns>That operator's points</returns>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.MonteCarloScheduler.MCP">
            <summary> Set the Monte Carlo Points function </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.MonteCarloScheduler.MCPQueueSize(System.Int32)">
            <summary> Point calculator based on queue size </summary>
            <param name="iOp">The operator to calculate</param>
            <returns>The points for that operator</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.MonteCarloScheduler.MCPRecent(System.Int32)">
            <summary> Point calculator based on most recently run operator</summary>
            <param name="iOp">The operator to calculate</param>
            <returns>The points for that operator</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.MonteCarloScheduler.Init(System.Boolean,WhitStream.QueryEngine.Query[])">
            <summary> Initialize the scheduler to execute the given query </summary>
            <param name="breakOut">Should the query operators run in their own thread?</param>
            <param name="qs">The query plans to execute</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.MonteCarloScheduler.AddQuery(System.Boolean,WhitStream.QueryEngine.Query[])">
            <summary> Add new queries to the scheduler during execution </summary>
            <param name="breakOutOperators">Should the query operators run in their own thread?</param>
            <param name="qs">The query plans to execute</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.MonteCarloScheduler.Execute">
            <summary> Execute the query </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.MonteCarloScheduler.Complete">
            <summary> Returns true if all data sources have been read to completion </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.MonteCarloScheduler.ToString">
            <summary> String to represent this scheduler </summary>
            <returns>String to represent this scheduler</returns>
        </member>
        <member name="T:WhitStream.QueryEngine.Scheduler.PriorityScheduler">
            <summary>
            A multi-threaded scheduler for executing a query using a priority algorithm
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.PriorityScheduler.Init(System.Boolean,WhitStream.QueryEngine.Query[])">
            <summary> Initialize the scheduler to execute the given query </summary>
            <param name="breakOut">Should the query operators run in their own thread?</param>
            <param name="qs">The query plans to execute</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.PriorityScheduler.AddQuery(System.Boolean,WhitStream.QueryEngine.Query[])">
            <summary> Add new queries to the scheduler during execution </summary>
            <param name="breakOutOperators">Should the query operators run in their own thread?</param>
            <param name="qs">The query plans to execute</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.PriorityScheduler.Execute">
            <summary> Execute the query </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.PriorityScheduler.ToString">
            <summary> String to represent this scheduler </summary>
            <returns>String to represent this scheduler</returns>
        </member>
        <member name="T:WhitStream.QueryEngine.Scheduler.DataEvent">
            <summary>
            Notifies listeners that something has occurred related to data (e.g. new results, EOF)
            </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.Scheduler.IResults">
            <summary>
            Interface to get results during the execution of a specific query
            </summary>
        </member>
        <member name="E:WhitStream.QueryEngine.Scheduler.IResults.DataArrived">
            <summary> New data is available </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.IResults.DataCount">
            <summary> How much data is currently available </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.IResults.Results">
            <summary> Return the current results for this query </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.IResults.Activate">
            <summary>Activate this query</summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.IResults.Deactivate">
            <summary>Deactivate this query</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.IResults.EndQuery">
            <summary> Has this query run to completion </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.Scheduler.IScheduler">
            <summary>
            Interface to be supported by all schedulers
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Scheduler.RoundRobinScheduler"/>
            <seealso cref="T:WhitStream.QueryEngine.Scheduler.MonteCarloScheduler"/>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.IScheduler.Init(System.Boolean,WhitStream.QueryEngine.Query[])">
            <summary> Initialize the scheduler to execute the given query </summary>
            <param name="qs">The query plans to execute</param>
            <param name="breakOutOperators">Should the query operators run in their own thread?</param>
            <returns>IResults objects to monitor the queries</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.IScheduler.AddQuery(System.Boolean,WhitStream.QueryEngine.Query[])">
            <summary>Add a query to this scheduler while it's executing</summary>
            <param name="breakOutOperators">Should each query operator run in its own thread, or the entire query in a thread?</param>
            <param name="qs">The queries to add</param>
            <returns>IResults objects to monitor the queries</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.IScheduler.Execute">
            <summary> Execute the query </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.IScheduler.Complete">
            <summary> Returns true if all data sources have been read to completion </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.IScheduler.OpThreads">
            <summary>List the operator threads that make up the queries to be executed </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.Scheduler.OpThread">
            <summary> Operator threads for WSThreadPool</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Scheduler.OpThread.LEFT">
            <summary>
            Constants for determining which queue to read/write
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Scheduler.OpThread.RIGHT">
            <summary>
            Constants for determining which queue to read/write
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.OpThread.#ctor">
            <summary>
            Simple constructor for creating a top-most OperatorThread object for the query plan
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.OpThread.Init(WhitStream.QueryEngine.Query,WhitStream.QueryEngine.Scheduler.OpThread,System.Int32,System.Boolean)">
            <summary> Initialize this OpThread </summary>
            <param name="q">Query operator to execute in this thread</param>
            <param name="parent">parent OpThread to write results to</param>
            <param name="parentQ">parent queue to write results to</param>
            <param name="inputQueues">Should this operator read from input queues?</param>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.OpThread.Complete">
            <summary> Is this thread done executing? </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.OpThread.QueueSize(System.Int32)">
            <summary> The number of data items in a specific thread's queue waiting to be processed </summary>
            <param name="q">Which queue (LEFT | RIGHT) </param>
            <returns>The count of data items</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.OpThread.HasEOF(System.Int32)">
            <summary> Does this queue have an EOF item in it? </summary>
            <param name="q">Which input queue (LEFT | RIGHT) </param>
            <returns>True if that queue contains an EOF item</returns>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.OpThread.QueryOperator">
            <summary> The query operator </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.OpThread.Leaf">
            <summary> Is this a leaf operator in the query? </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.OpThread.OTParent">
            <summary> Set the parent OpThread for this operator </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.OpThread.OTParentQueue">
            <summary> Set the destination queue for this operator </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.OpThread.Busy">
            <summary> Is this thread already executing? </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.OpThread.Active">
            <summary> Is this thread part of an active query? </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.OpThread.SetInputQueues">
            <summary> Set up the input queue(s) for this operator </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.OpThread.GetQueueCount">
            <summary> How many queues are used for this operator? </summary>
            <returns>The total number of input queues</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.OpThread.GetQueue(System.Int32)">
            <summary> Get the queue operator for this operator </summary>
            <param name="i">Which queue (LEFT | RIGHT)</param>
            <returns>The queue input for this operator</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.OpThread.AddDataToQueue(System.Collections.Generic.List{WhitStream.Data.DataItem},System.Int32)">
            <summary>
            Add data to the parent queue for processing
            </summary>
            <param name="rgdiNew">The new data to be added</param>
            <param name="q">Which queue (LEFT, RIGHT) to write to</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.OpThread.ExecuteOnce(WhitStream.Utility.DataItemPool.GetDataItem,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Execute the query operator for this thread
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.OpThread.ToString">
            <summary> Output stats for this thread </summary>
            <returns>String with thread-specific stats</returns>
        </member>
        <member name="T:WhitStream.QueryEngine.Scheduler.ParentOperatorThread">
            <summary>
            Operator to be used at the top of query plans
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.#ctor">
            <summary> Default constructor </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.Init(WhitStream.QueryEngine.Query,WhitStream.QueryEngine.Scheduler.OpThread,System.Int32,System.Boolean)">
            <summary> Initialize this OpThread </summary>
            <param name="q">Query to initialize with</param>
            <param name="parent">Parent OpThread to write results to</param>
            <param name="parentQueue">queue to write results to</param>
            <param name="inputQueues">Should this operator read from input queues?</param>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.Complete">
            <summary> Is this query done? </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.QueueSize(System.Int32)">
            <summary> The number of data items in a specific thread's queue waiting to be processed </summary>
            <param name="q">Which queue (LEFT | RIGHT) </param>
            <returns>The count of data items</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.HasEOF(System.Int32)">
            <summary> Does this queue have an EOF item in it? </summary>
            <param name="q">Which input queue (LEFT | RIGHT) </param>
            <returns>True if that queue contains an EOF item</returns>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.QueryOperator">
            <summary> Return this query operator </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.Leaf">
            <summary> Is this query operator a leaf in the query plan? </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.OTParent">
            <summary> Set up the parent OpThread for this thread. </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.OTParentQueue">
            <summary> Set up the destination queue for this operator </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.SetInputQueues">
            <summary> Set up the input queue(s) for this operator </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.GetQueue(System.Int32)">
            <summary> Get the input queue for this operator (LEFT | RIGHT) </summary>
            <param name="i"> Which queue (LEFT | RIGHT)? </param>
            <returns>The desired OpQueue object</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.AddDataToQueue(System.Collections.Generic.List{WhitStream.Data.DataItem},System.Int32)">
            <summary> Add new data items into this input queue </summary>
            <param name="rgdiNew">The data items to add</param>
            <param name="q">Which queue to write to (LEFT | RIGHT) </param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.ExecuteOnce(WhitStream.Utility.DataItemPool.GetDataItem,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary> The thread function to run one time </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.AddChild(WhitStream.QueryEngine.Scheduler.OpThread)">
            <summary>Add a child to this query</summary>
            <param name="ot">The child to add</param>
        </member>
        <member name="E:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.DataArrived">
            <summary> New data is available to be read </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.DataCount">
            <summary>How much data is available</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.Results">
            <summary> Return the results for this operator </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.EndQuery">
            <summary> Is this query done? </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.Activate">
            <summary> Activate this query for this operator </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.ParentOperatorThread.Deactivate">
            <summary> Deactivate this query </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.Scheduler.WSThreadPool">
            <summary>
            Manage a pool of threads for the scheduler
            </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.Scheduler.WSThreadPool.NextOperator">
            <summary> Function to determine which operator to execute next </summary>
            <returns>The operator to execute</returns>
        </member>
        <member name="F:WhitStream.QueryEngine.Scheduler.WSThreadPool.COMPLETE">
            <summary> Nothing more to do </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Scheduler.WSThreadPool.THREADHISTORY">
            <summary> How much history should we keep? </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.WSThreadPool.#ctor">
            <summary>Default constructor for WSThreadPool</summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.WSThreadPool.#ctor(System.Int32)">
            <summary>Specify how many threads for thread pool</summary>
            <param name="threads">how many threads to execute</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.WSThreadPool.Init(System.Collections.Generic.List{WhitStream.QueryEngine.Scheduler.OpThread},WhitStream.QueryEngine.Scheduler.WSThreadPool.NextOperator)">
            <summary> Initialize the pool </summary>
            <param name="ots">The OperatorThread objects that are participating</param>
            <param name="n">The function to call to get the next operator to execute</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.WSThreadPool.AddQuery(System.Collections.Generic.List{WhitStream.QueryEngine.Scheduler.OpThread})">
            <summary>Add a query to this scheduler while it's executing</summary>
            <param name="ots">The operator threads to add`</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.WSThreadPool.Start">
            <summary> Begin query execution </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.WSThreadPool.GetLastExecuted(System.Int32)">
            <summary> What were the last operators executed? </summary>
            <param name="i">Index into history (0=Most recent, THREADHISTORY-1=Least Recent</param>
            <returns>Which operator was most recently run</returns>
            <seealso cref="F:WhitStream.QueryEngine.Scheduler.WSThreadPool.THREADHISTORY"/>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.WSThreadPool.RemoveAt(System.Int32)">
            <summary> Remove a completed thread from the pool </summary>
            <param name="i">The thread to remove</param>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.WSThreadPool.Item(System.Int32)">
            <summary> Allow for index access to the active threads in the pool </summary>
            <param name="iActive">Which thread to access</param>
            <returns>That thread</returns>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.WSThreadPool.Length">
            <summary> How many threads are in the pool? </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.WSThreadPool.GetEnumerator">
            <summary> Return the enumerator for this class, so we can do foreach </summary>
            <returns> this object, which supports IEnumerator</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.WSThreadPool.Dispose">
            <summary> Clean up after ourselves </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.Scheduler.Scheduler">
            <summary>
            Scheduler abstract class
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Scheduler.Scheduler.ots">
            <summary> The OperatorThreads that make up the queries to be executed </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.Scheduler.OpThreads">
            <summary>List the operator threads that make up the queries to be executed </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.Scheduler.Init(System.Boolean,WhitStream.QueryEngine.Query[])">
            <summary> Initialize the scheduler to execute the given query </summary>
            <param name="breakOutOperators">Should the query be broken up so that each operator runs in its own thread?</param>
            <param name="qs">The query plan to execute</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.Scheduler.AddQuery(System.Boolean,WhitStream.QueryEngine.Query[])">
            <summary> Add a new query to the existing pool of queries </summary>
            <param name="breakOutOperators">Should the query be broken up so that each operator runs in its own thread?</param>
            <param name="qs">The query plans to add</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.Scheduler.Execute">
            <summary> Execute the query </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Scheduler.Scheduler.Complete">
            <summary> Returns true if all data sources have been read to completion </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.Scheduler.BuildPlan(WhitStream.QueryEngine.Query[],System.Boolean)">
            <summary>
            Initialize the scheduler with a query. The operators given will define
            the query to be executed. A thread pool is created with each operator
            and its input queue running in its own thread.
            </summary>
            <param name="qs">The simple (pull-based) query plans</param>
            <param name="fBreakOut">Should we break this query into separate threads?</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Scheduler.Scheduler.ToString">
            <summary>String representation of this scheduler</summary>
            <returns>String representation of this scheduler</returns>
        </member>
        <member name="T:WhitStream.QueryEngine.Step">
            <summary>
            Delegate function for query operator to iterate one step due to new, incoming data
            </summary>
            <param name="di">The incoming DataItem object</param>
            <param name="ldi">Any new DataItem objects that can be output due to the incoming DataItem</param>
            <seealso cref="T:WhitStream.Data.DataItem" />
            <seealso cref="M:WhitStream.QueryEngine.Query.StepTrivial(WhitStream.Data.DataItem,System.Collections.Generic.List{WhitStream.Data.DataItem})"/>
        </member>
        <member name="T:WhitStream.QueryEngine.StepList">
            <summary>
            Delegate function for query operator to iterate one step due to new, incoming list of data
            </summary>
            <param name="rgdi">The incoming DataItem object</param>
            <param name="eofInput">Whether EOF was found in teh input</param>
            <param name="ldi">Any new DataItem objects that can be output due to the incoming DataItem</param>
            <seealso cref="T:WhitStream.Data.DataItem" />
            <seealso cref="M:WhitStream.QueryEngine.Query.StepTrivial(WhitStream.Data.DataItem,System.Collections.Generic.List{WhitStream.Data.DataItem})"/>
        </member>
        <member name="T:WhitStream.QueryEngine.Final">
            <summary>
            Delegate function for query operator to finish processing, as the source is complete
            </summary>
            <param name="ldi">Any new DataItem objects that can be output at the end of the input</param>
            <seealso cref="T:WhitStream.Data.DataItem" />
            <seealso cref="M:WhitStream.QueryEngine.Query.FinalTrivial(System.Collections.Generic.List{WhitStream.Data.DataItem})"/>
        </member>
        <member name="T:WhitStream.QueryEngine.Pass">
            <summary>
            Delegate function for query operator to output data items early due to punctuations
            </summary>
            <param name="p">The incoming punctuation</param>
            <param name="ldi">Any new DataItem objects that can be output due to input punctuation</param>
            <seealso cref="T:WhitStream.Data.DataItem" />
            <seealso cref="T:WhitStream.Data.Punctuation" />
            <seealso cref="M:WhitStream.QueryEngine.Query.PassTrivial(WhitStream.Data.Punctuation,System.Collections.Generic.List{WhitStream.Data.DataItem})"/>
        </member>
        <member name="T:WhitStream.QueryEngine.Keep">
            <summary>
            Delegate function for query operator to decrease required state, if possible, due to punctuation
            </summary>
            <seealso cref="T:WhitStream.Data.DataItem" />
            <seealso cref="T:WhitStream.Data.Punctuation" />
            <seealso cref="M:WhitStream.QueryEngine.Query.KeepTrivial(WhitStream.Data.Punctuation)"/>
        </member>
        <member name="T:WhitStream.QueryEngine.Prop">
            <summary>
            Delegate function for query operator to output punctuations due to incoming punctuation
            </summary>
            <param name="p">The incoming punctuation</param>
            <param name="ldi">Any new Punctuation objects that can be output</param>
            <seealso cref="T:WhitStream.Data.DataItem" />
            <seealso cref="T:WhitStream.Data.Punctuation" />
            <seealso cref="M:WhitStream.QueryEngine.Query.PropTrivial(WhitStream.Data.Punctuation,System.Collections.Generic.List{WhitStream.Data.DataItem})"/>
        </member>
        <member name="T:WhitStream.QueryEngine.Query">
            <summary>
            Interface to model execution of a query operator
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.DATABUFFERSIZE">
            <summary> Initial buffer size for data for this operator </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.PUNCTBUFFERSIZE">
            <summary>Initial buffer size for punctuations for this operator </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.itemsIn">
            <summary>The number of items that have moved through this operator</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.itemsOut">
            <summary>The number of items that have moved through this operator</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.opID">
            <summary> ID for this operator in the query </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.eof">
            <summary> Whether this operator has completed execution </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.diEOF">
            <summary> Data item representing EOF </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.#ctor">
            <summary>
            Constructor sets operator ID for this operator and increments the OpID seed
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Query.OpID">
            <summary>
            Returns the opID for this operator
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.Query.EOF">
            <summary>
            Returns whether this operator has completed execution
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.XMLQUERYTOPLEVEL">
            <summary> String for serialization to XML </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.XMLTOPID">
            <summary> String for serialization to XML </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.XMLOPID">
            <summary> String for serialization to XML </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.XMLINPUTID">
            <summary> String for serialization to XML </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.XMLINPUTCOUNT">
            <summary> String for serializaation the number of inputs to XML (NAry operators only) </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.XMLLEFTINPUTID">
            <summary> String for serialization to XML </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.XMLRIGHTINPUTID">
            <summary> String for serialization to XML </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.ToString">
            <summary> Output stats for this operator </summary>
            <returns>String with operator-specific stats</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.Serialize(System.String)">
            <summary>
            Serialize this query
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.Serialize">
            <summary>
            Serialize this query to the console
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.SerializeOp(System.IO.TextWriter)">
            <summary>
            Serialize this specific operator
            </summary>
            <remarks> We should never get here, but its in for completeness </remarks>
        </member>
        <member name="T:WhitStream.QueryEngine.Query.OperatorParams">
            <summary>
            Parameters for query operators, so that we can
            construct operators for them
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.OperatorParams.opName">
            <summary> Type name for this operator </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.OperatorParams.rginputs">
            <summary> Input operator ids for this operator </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.Query.OperatorParams.opParams">
            <summary> Any initialization parameters for this operator </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.Deserialize(System.String)">
            <summary>
            Load a query from a file
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.Benefit(WhitStream.Data.PunctuationScheme)">
            <summary>
            Determines if the operator benefits from the punctuation scheme
            </summary>
            <param name="ps">The punctuation scheme to be tested</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.GetItemsReady">
            <summary>
            Determines how many data items are ready to be processed from the source of this query
            </summary>
            <returns></returns>
        </member>
        <member name="P:WhitStream.QueryEngine.Query.Selectivity">
            <summary>What is the Ratio of items input to items returned?</summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.DeserializeOp(System.IO.TextWriter)">
            <summary>
            Load this specific operator
            </summary>
            <remarks> We should never get here </remarks> 
        </member>
        <member name="M:WhitStream.QueryEngine.Query.Iterate(WhitStream.Utility.DataItemPool.GetDataItem,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Read DataItems iteratively from the source query operator(s)
            </summary>
            <returns>Any DataItem objects to be output</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.Activate">
            <summary>
            Let this operator know that it has been activated
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.Deactivate">
            <summary>
            Let this operator know that it has been deactivated
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.SplitPunc(System.Collections.Generic.List{WhitStream.Data.DataItem},System.Collections.Generic.List{WhitStream.Data.DataItem}@,System.Collections.Generic.List{WhitStream.Data.Punctuation}@)">
            <summary>
            Split out the punctuations from the data items
            </summary>
            <param name="ldiIn">The input data items (and possibly punctuations)</param>
            <param name="ldiOut">The data items in the input</param>
            <param name="lpOut">The punctuations in the input</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.StepTrivial(WhitStream.Data.DataItem,System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Trivial step functionality : ignore the input continue
            </summary>
            <param name="di">The input data item</param>
            <param name="ldi">The output data items</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.StepListTrivial(System.Collections.Generic.List{WhitStream.Data.DataItem},System.Collections.Generic.List{WhitStream.Data.DataItem}@,System.Boolean@)">
            <summary>
            Trivial step functionality : ignore the input continue
            </summary>
            <param name="rgdi">The input data item</param>
            <param name="eofInput">Whether or not the input contained eof</param>
            <param name="ldi">The output data items</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.FinalTrivial(System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Trivial final functionality : return nothing
            </summary>
            <param name="ldi">Output data items</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.PassTrivial(WhitStream.Data.Punctuation,System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Trivial pass functionality : ignore the input continue
            </summary>
            <param name="p">The input punctuation</param>
            <param name="ldi">Output data items</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.KeepTrivial(WhitStream.Data.Punctuation)">
            <summary>
            Trivial keep functionality : ignore the input continue
            </summary>
            <param name="p">The input punctuation</param>
        </member>
        <member name="M:WhitStream.QueryEngine.Query.PropTrivial(WhitStream.Data.Punctuation,System.Collections.Generic.List{WhitStream.Data.DataItem})">
            <summary>
            Trivial prop functionality : ignore the input continue
            </summary>
            <param name="p">The input punctuation</param>
            <param name="ldi">The output punctuations due to this punctuation</param>
        </member>
        <member name="T:WhitStream.QueryEngine.UnaryAlgorithmDefinition">
            <summary>Interface for all algorithm definitions</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithmDefinition.StateSize">
            <summary> How many data items are curently held in state </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithmDefinition.GetDataItem">
            <summary>Property for the GetDataItem DataPool method</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithmDefinition.ReleaseDataItem">
            <summary>Property for the ReleaseDataItem DataPool method</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithmDefinition.FnStep">
            <summary>Default Step functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithmDefinition.FnStepList">
            <summary>Default StepList functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithmDefinition.FnPass">
            <summary>Default Pass functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithmDefinition.FnProp">
            <summary>Default Prop functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithmDefinition.FnKeep">
            <summary>Default Keep functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithmDefinition.FnFinal">
            <summary>Default Final functionality</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.UnaryAlgorithm">
            <summary>
            Class for specifying algorithms for a particular operator
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.UnaryAlgorithm.#ctor(WhitStream.QueryEngine.UnaryAlgorithmDefinition)">
            <summary>
            Constructor with specific algorithm definition
            </summary>
            <param name="def">The object defining the algorith to use</param>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithm.GetDataItem">
            <summary>Property for the GetDataItem DataPool method</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithm.ReleaseDataItem">
            <summary>Property for the ReleaseDataItem DataPool method</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithm.FnStep">
            <summary>
            Property to set the Step function for this operator
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Step"/>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithm.FnStepList">
            <summary>
            Property to set the StepList function for this operator
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.StepList"/>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithm.FnFinal">
            <summary>
            Property to set the Final function for this operator
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Final"/>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithm.FnPass">
            <summary>
            Property to set the Pass function for this operator
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Pass"/>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithm.FnKeep">
            <summary>
            Property to set the Keep function for this operator
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Keep"/>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryAlgorithm.FnProp">
            <summary>
            Property to set the Propagation function for this operator
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Prop"/>
        </member>
        <member name="T:WhitStream.QueryEngine.UnaryOp">
            <summary>
            Models general behavior of a unary query operator (e.g. Select, Project)
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.UnaryOp.ldiBuffer">
            <summary> Buffer for containing input data for each iteration </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.UnaryOp.lpBuffer">
            <summary> Buffer for containing input punctuations for each iteration </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.UnaryOp.ldiBufferOut">
            <summary> Output data item buffer </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.UnaryOp.algorithm">
            <summary>
            The algorithm to use for this operator
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.UnaryAlgorithm"/>
        </member>
        <member name="F:WhitStream.QueryEngine.UnaryOp.opIn">
            <summary>
            The input to this unary query operator
            </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.UnaryOp.Map">
            <summary>
            Delegate for functions that map DataItem objects into DataItem objects
            of a different format
            </summary>
            <param name="di" >The DataItem object to process</param>
            <returns>A possibly modified DataItem</returns>
        </member>
        <member name="T:WhitStream.QueryEngine.UnaryOp.Relation">
            <summary>Delegate function to perform an operation on a data item with access to a table</summary>
            <param name="di">The data item to operate on</param>
            <param name="rt">The table to use</param>
            <returns>A possibly modified data item</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.UnaryOp.#ctor">
            <summary>
            dummy constructor
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.UnaryOp.#ctor(WhitStream.QueryEngine.Query)">
            <summary>
            Constructor to set up a unary operator with its input
            </summary>
            <param name="op">The input to this operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.UnaryOp.Activate">
            <summary>
            Let this operator know that it has been activated
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.UnaryOp.Deactivate">
            <summary>
            Let this operator know that it has been deactivated
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.UnaryOp.SerializeOp(System.IO.TextWriter)">
            <summary>
            Serialize this specific operator
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.UnaryOp.Input">
            <summary>
            The input operator to this operator
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.UnaryOp.GetItemsReady">
            <summary>
            Finds the number of tuples ready from the child operator
            </summary>
            <returns>The number of items ready to be processed</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.UnaryOp.Iterate(WhitStream.Utility.DataItemPool.GetDataItem,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Iterate function to work through data items.
            The Step function is called with each data item that arrives.
            The Final function is called when EOF is encountered
            </summary>
            <returns>DataItem objects that can be output from this iteration</returns>
            <seealso cref="T:WhitStream.QueryEngine.Step"/>
            <seealso cref="T:WhitStream.QueryEngine.Final"/>
        </member>
        <member name="T:WhitStream.QueryEngine.BinaryAlgorithmDefinition">
            <summary>Interface for all algorithm definitions</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.StateSize">
            <summary> How many data items are curently held in state </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.GetDataItem">
            <summary>Property for the GetDataItem DataPool method</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.ReleaseDataItem">
            <summary>Property for the ReleaseDataItem DataPool method</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.FnStepLeft">
            <summary>Default Step functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.FnStepRight">
            <summary>Default Step functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.FnStepListLeft">
            <summary>Default StepList functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.FnStepListRight">
            <summary>Default StepList functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.FnPassLeft">
            <summary>Default Pass functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.FnPassRight">
            <summary>Default Pass functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.FnPropLeft">
            <summary>Default Prop functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.FnPropRight">
            <summary>Default Prop functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.FnKeepLeft">
            <summary>Default Keep functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.FnKeepRight">
            <summary>Default Keep functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.FnFinalLeft">
            <summary>Default Final functionality</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithmDefinition.FnFinalRight">
            <summary>Default Final functionality</summary>
        </member>
        <member name="T:WhitStream.QueryEngine.BinaryAlgorithm">
            <summary>
            Class for specifying algorithms for a particular operator
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.BinaryAlgorithm.#ctor">
            <summary>
            Default constructor -- algorithm is the trivial (identity) algorithm
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.BinaryAlgorithm.#ctor(WhitStream.QueryEngine.BinaryAlgorithmDefinition)">
            <summary>
            Constructor with specific algorithm definition
            </summary>
            <param name="def">The object defining the algorith to use</param>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.GetDataItem">
            <summary>Property for the GetDataItem DataPool method</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.ReleaseDataItem">
            <summary>Property for the ReleaseDataItem DataPool method</summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.FnStepLeft">
            <summary>
            Property to set the Step function for this operator's left input
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Step"/>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.FnStepRight">
            <summary>
            Property to set the Step function for this operator's right input
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Step"/>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.FnStepListLeft">
            <summary>
            Property to set the StepList function for this operator's left input
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.StepList"/>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.FnStepListRight">
            <summary>
            Property to set the StepList function for this operator's right input
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.StepList"/>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.FnFinalLeft">
            <summary>
            Property to set the Final function for this operator's left input
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Final"/>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.FnFinalRight">
            <summary>
            Property to set the Final function for this operator's right input
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Final"/>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.FnPassLeft">
            <summary>
            Property to set the Pass function for this operator's left input
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Pass"/>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.FnPassRight">
            <summary>
            Property to set the Pass function for this operator's right input
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Pass"/>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.FnKeepLeft">
            <summary>
            Property to set the Keep function for this operator's left input
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Keep"/>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.FnKeepRight">
            <summary>
            Property to set the Keep function for this operator's right input
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Keep"/>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.FnPropLeft">
            <summary>
            Property to set the Propagation function for this operator's left input
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Prop"/>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryAlgorithm.FnPropRight">
            <summary>
            Property to set the Propagation function for this operator's right input
            </summary>
            <seealso cref="T:WhitStream.QueryEngine.Prop"/>
        </member>
        <member name="T:WhitStream.QueryEngine.BinaryOp">
            <summary>
            Models general behavior of binary query operators
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.BinaryOp.ldiBufferLeft">
            <summary> Buffer for input data from the left input for each iteration</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.BinaryOp.lpBufferLeft">
            <summary> Buffer for input punctuation from the left input for each iteration</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.BinaryOp.ldiBufferRight">
            <summary> Buffer for input data from the rightinput for each iteration</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.BinaryOp.lpBufferRight">
            <summary> Buffer for input punctuation from the right input for each iteration</summary>
        </member>
        <member name="F:WhitStream.QueryEngine.BinaryOp.ldiBufferOut">
            <summary> Buffer for output data items </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.BinaryOp.algorithm">
            <summary>
            The algorithm(s) to execute
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.BinaryOp.opInLeft">
            <summary>
            The left and right input operators for this binary operator
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.BinaryOp.opInRight">
            <summary>
            The left and right input operators for this binary operator
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.BinaryOp.fLeftEOF">
            <summary>
            Whether EOF has been reached on the left and right inputs, respectively.
            </summary>
        </member>
        <member name="F:WhitStream.QueryEngine.BinaryOp.fRightEOF">
            <summary>
            Whether EOF has been reached on the left and right inputs, respectively.
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.BinaryOp.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.BinaryOp.#ctor(WhitStream.QueryEngine.Query,WhitStream.QueryEngine.Query)">
            <summary>
            Constructor for a binary operator
            </summary>
            <param name="opL">The left input query operator</param>
            <param name="opR">The right input query operator</param>
        </member>
        <member name="M:WhitStream.QueryEngine.BinaryOp.Activate">
            <summary>
            Let this operator know that it has been activated
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.BinaryOp.Deactivate">
            <summary>
            Let this operator know that it has been deactivated
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.BinaryOp.SerializeOp(System.IO.TextWriter)">
            <summary>
            Serialize this specific operator
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryOp.LeftInput">
            <summary>
            The left-side input operator to this operator
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.BinaryOp.RightInput">
            <summary>
            The right-side input operator to this operator
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.BinaryOp.Pair(WhitStream.Data.DataItem,WhitStream.Data.DataItem,WhitStream.Utility.DataItemPool.GetDataItem)">
            <summary>
            Combine two DataItem objects (in cross-product fashion)
            </summary>
            <param name="diL">Left DataItem object</param>
            <param name="diR">Right DataItem object</param>
            <param name="gdi">GetDataItem function</param>
            <returns>a data item which is a pair of the given data items</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.BinaryOp.GetItemsReady">
            <summary>
            Finds the number of tuples ready from the child operators
            </summary>
            <returns>The number of items ready to be processed</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.BinaryOp.Iterate(WhitStream.Utility.DataItemPool.GetDataItem,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Iterate function to work through data items.
            The Step functions are called with each data item that arrives from each input.
            The Final functions aer called when EOF is encountered on each input
            </summary>
            <returns>DataItem objects that can be output from this iteration</returns>
            <seealso cref="T:WhitStream.QueryEngine.Step"/>
            <seealso cref="T:WhitStream.QueryEngine.Final"/>
        </member>
        <member name="T:WhitStream.QueryEngine.NAryOp">
            <summary>
            Class to model operators with n inputs
            </summary>
        </member>
        <member name="T:WhitStream.QueryEngine.NAryOp.NextInput">
            <summary>
            Function to determine which input to read from next
            </summary>
            <returns>the input index to read from</returns>
        </member>
        <member name="P:WhitStream.QueryEngine.NAryOp.Next">
            <summary>
            Function to determine which input to read from next
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.NAryOp.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.NAryOp.#ctor(WhitStream.QueryEngine.Query[])">
            <summary>
            Constructor with all inputs for this operator
            </summary>
            <param name="qsInput">The input query operators</param>
        </member>
        <member name="M:WhitStream.QueryEngine.NAryOp.Activate">
            <summary>
            Let this operator know that it has been activated
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.NAryOp.Deactivate">
            <summary>
            Let this operator know that it has been deactivated
            </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.NAryOp.SerializeOp(System.IO.TextWriter)">
            <summary>
            Serialize this specific operator
            </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.NAryOp.Inputs">
            <summary> Accessor to the input operators </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.NAryOp.CurrentInput">
            <summary> Which inputs are we currently reading from? </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.NAryOp.StepFunctions">
            <summary> Accessor to the Step functions for this operator </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.NAryOp.StepListFunctions">
            <summary> Accessor to the StepList functions for this operator </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.NAryOp.FinalFunctions">
            <summary> Accessor to the Final functions for this operator </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.NAryOp.PassFunctions">
            <summary> Accessor to the Pass functions for this operator </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.NAryOp.PropFunctions">
            <summary> Accessor to the Prop functions for this operator </summary>
        </member>
        <member name="P:WhitStream.QueryEngine.NAryOp.KeepFunctions">
            <summary> Accessor to the Keep functions for this operator </summary>
        </member>
        <member name="M:WhitStream.QueryEngine.NAryOp.NextInputRoundRobin">
            <summary>
            Read each input in turn
            </summary>
            <returns>the next input to read</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.NAryOp.GetItemsReady">
            <summary>
            Finds the number of tuples ready from the child operators
            </summary>
            <returns>The number of items ready to be processed</returns>
        </member>
        <member name="M:WhitStream.QueryEngine.NAryOp.Iterate(WhitStream.Utility.DataItemPool.GetDataItem,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Iterate function to work through data items.
            The Step functions are called with each data item that arrives from one chosen input
            The Final functions are called when EOF is encountered on each input
            </summary>
            <returns>DataItem objects that can be output from this iteration</returns>
            <seealso cref="T:WhitStream.QueryEngine.Step"/>
            <seealso cref="T:WhitStream.QueryEngine.Final"/>
        </member>
        <member name="T:WhitStream.Data.DataItem">
            <summary>
            Class to model a data item from a source (stream or table)
            </summary>
        </member>
        <member name="F:WhitStream.Data.DataItem.dvm">
            <summary>Pool of arraylists for values</summary>
        </member>
        <member name="F:WhitStream.Data.DataItem.alValues">
            <summary>Values for this data item</summary>
        </member>
        <member name="F:WhitStream.Data.DataItem.cAttrs">
            <summary>Number of attributes in the data item</summary>
        </member>
        <member name="F:WhitStream.Data.DataItem.m_storedCount">
            <summary>How many attributes are in this item</summary>
        </member>
        <member name="F:WhitStream.Data.DataItem.fEOF">
            <summary>Whether or not we've reached the end of the data source</summary>
        </member>
        <member name="F:WhitStream.Data.DataItem.reldataitem">
            <summary>The data pool used to create this data item, so we can release it</summary>
        </member>
        <member name="M:WhitStream.Data.DataItem.#ctor(System.Int32,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Constructor for creating a data item with the given number of attributes
            </summary>
            <param name="c">The number of attributes to track</param>
            <param name="r">Delegate to release data item back to data pool</param>
        </member>
        <member name="M:WhitStream.Data.DataItem.#ctor(WhitStream.Data.DataItem,System.UInt32,WhitStream.Utility.DataItemPool.ReleaseDataItem)">
            <summary>
            Copy constructor for a data item
            </summary>
            <param name="di">The data item to copy</param>
            <param name="c">The number of attributes more to track than the input data item has</param>
            <param name="r">Delegate to release data item back to data pool</param>
        </member>
        <member name="M:WhitStream.Data.DataItem.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor to create a data item from a serialized one
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:WhitStream.Data.DataItem.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Override method to create a serialized data item
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:WhitStream.Data.DataItem.EOF">
            <summary>
            Property to determine if this is the last data item from the source
            </summary>
        </member>
        <member name="P:WhitStream.Data.DataItem.TimeStamp">
            <summary>The time the data item came into the system</summary>
        </member>
        <member name="P:WhitStream.Data.DataItem.Count">
            <summary>
            Property to determine how many attributes are in the data item
            </summary>
        </member>
        <member name="M:WhitStream.Data.DataItem.AddValue(System.Object)">
            <summary>
            Append an attribute value to the data item
            </summary>
            <param name="o"></param>
        </member>
        <member name="P:WhitStream.Data.DataItem.Item(System.Int32)">
            <summary>
            Support indexing on a particular attribute
            </summary>
            <param name="i">The attribute to read/write</param>
            <returns>The value for that attribute</returns>
        </member>
        <member name="M:WhitStream.Data.DataItem.GetValue(System.Int32)">
            <summary>
            Gets a value from the data item at a position
            </summary>
            <param name="position">Position in the list</param>
            <returns></returns>
        </member>
        <member name="M:WhitStream.Data.DataItem.Equals(System.Object)">
            <summary>
            Determine if two data items are equal (based on values of attributes)
            </summary>
            <param name="obj">The data item to compare to</param>
            <returns>True if the data items are equal</returns>
        </member>
        <member name="M:WhitStream.Data.DataItem.GetHashCode">
            <summary>
            Compute a hash code for this data item
            </summary>
            <returns>The hash code for this object</returns>
        </member>
        <member name="M:WhitStream.Data.DataItem.GetSpecificHashCode(System.Int32[])">
            <summary>
            Compute a hash code for this data item based on specific attributes
            </summary>
            <param name="attrs">The attributes to read from</param>
            <returns>True if the data items are equal</returns>
        </member>
        <member name="M:WhitStream.Data.DataItem.ToString">
            <summary>
            A string representation of the data item
            </summary>
            <returns></returns>
        </member>
        <member name="M:WhitStream.Data.DataItem.Mask(System.Int32,System.Boolean)">
            <summary>
            Mask the given position
            </summary>
            <param name="position">The zero-based position to mask</param>
            <param name="on">On (true) means that the attribute will be visible</param>
        </member>
        <member name="M:WhitStream.Data.DataItem.FindMaskFromPosition(System.Int32)">
            <summary>
            Find the correct position based on an initial position of a data item in the list
            </summary>
            <param name="initialPosition">The initial position to use</param>
            <returns>The correct position</returns>
            <remarks>This is necessary to find the position if a data mask has been turned off</remarks>
        </member>
        <member name="M:WhitStream.Data.DataItem.ResetMask">
            <summary>
            Reset the mask back to 0
            </summary>
        </member>
        <member name="P:WhitStream.Data.DataItem.Disposed">
            <summary>
            Have we already released this dataitem back to the queue
            </summary>
        </member>
        <member name="M:WhitStream.Data.DataItem.Dispose">
            <summary>
            Release this data item back to the pool
            </summary>
        </member>
        <member name="M:WhitStream.Data.DataItem.Clear">
            <summary>
            Completely resets this data item
            </summary>
        </member>
        <member name="M:WhitStream.Data.DataItem.AddCapacity(System.UInt32)">
            <summary>
            Add the capcity for more attributes to the data item
            </summary>
            <param name="count">The number of attributes more to track</param>
        </member>
        <member name="T:WhitStream.Data.Punctuation">
            <summary>
            Represents a punctuation.
            </summary>
            <seealso cref="T:WhitStream.Data.DataItem"/>
        </member>
        <member name="T:WhitStream.Data.Punctuation.Pattern">
            <summary>
            Pattern objects for punctuation attributes
            </summary>
        </member>
        <member name="M:WhitStream.Data.Punctuation.Pattern.Match(System.Object)">
            <summary>
            Return true if the given value matches the pattern
            </summary>
            <param name="o">The value to match on</param>
            <returns>Whether the value matches the pattern</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.Pattern.Coerce(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the coercion (union) of the two patterns, if possible
            </summary>
            <param name="p">the pattern to coerce</param>
            <returns>the coercion (union) of the two patterns, or EmptyPattern if they cannot
            be coerced.</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.Pattern.Uncoerce(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the removal of the given pattern from this punctuation, if possible
            </summary>
            <param name="p">the pattern to uncoerce</param>
            <returns>the "uncoercion" of the two patterns, or EmptyPattern if they cannot
            be uncoerced.</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.Pattern.Combine(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the combination (intersection) of the given pattern to this pattern, if possible
            </summary>
            <param name="p">the pattern to combine</param>
            <returns>the combination (intersection) of the two patterns, or EmptyPattern if they cannot
            be combined.</returns>
        </member>
        <member name="T:WhitStream.Data.Punctuation.WildcardPattern">
            <summary>
            The wildcard pattern matches all data item values
            </summary>
        </member>
        <member name="M:WhitStream.Data.Punctuation.WildcardPattern.Match(System.Object)">
            <summary>
            Always returns true
            </summary>
            <param name="o">The object to match on</param>
            <returns>Always true</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.WildcardPattern.Coerce(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the coercion of the two patterns, which will always be the wildcard
            </summary>
            <param name="p">the pattern to coerce</param>
            <returns>the wildcard, since it subsumes all other patterns.</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.WildcardPattern.Uncoerce(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the uncoercion of the two patterns, which will always be the wildcard
            </summary>
            <param name="p">the pattern to uncoerce</param>
            <returns>the wildcard, since it subsumes all other patterns.</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.WildcardPattern.Combine(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the combination of p with the wildcard, which is always p
            </summary>
            <param name="p">the pattern to combine with</param>
            <returns>the combined pattern (always p)</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.WildcardPattern.Equals(System.Object)">
            <summary>
            Compares WildcardPattern objects for equality
            </summary>
            <param name="obj">the pattern to compare</param>
            <returns>true if the two patterns are equal</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.WildcardPattern.ToString">
            <summary>
            A string representation of the pattern
            </summary>
            <returns></returns>
        </member>
        <member name="T:WhitStream.Data.Punctuation.EmptyPattern">
            <summary>
            The empty pattern matches no data item values
            </summary>
        </member>
        <member name="M:WhitStream.Data.Punctuation.EmptyPattern.Match(System.Object)">
            <summary>
            Always returns false
            </summary>
            <param name="o">The object to match on</param>
            <returns>Always false</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.EmptyPattern.Coerce(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the coercion of the two patterns, which will always be the incoming pattern
            </summary>
            <param name="p">the pattern to coerce</param>
            <returns>the incoming pattern, since it subsumes the empty pattern.</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.EmptyPattern.Uncoerce(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the uncoercion of the two patterns, which will always be the empty pattern
            </summary>
            <param name="p">the pattern to uncoerce</param>
            <returns>the empty pattern.</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.EmptyPattern.Combine(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the combination of p with the empty, which is always the empty pattern
            </summary>
            <param name="p">the pattern to combine with</param>
            <returns>the combined pattern (always empty)</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.EmptyPattern.Equals(System.Object)">
            <summary>
            Compares EmptyPattern objects for equality
            </summary>
            <param name="obj">the pattern to compare</param>
            <returns>true if the two patterns are equal</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.EmptyPattern.ToString">
            <summary>
            A string representation of the pattern
            </summary>
            <returns></returns>
        </member>
        <member name="T:WhitStream.Data.Punctuation.LiteralPattern">
            <summary>
            A pattern to match on a singleton value
            </summary>
        </member>
        <member name="M:WhitStream.Data.Punctuation.LiteralPattern.#ctor(System.Object)">
            <summary>
            Constructs a pattern that matches a single value
            </summary>
            <param name="o">The pattern to match on</param>
        </member>
        <member name="P:WhitStream.Data.Punctuation.LiteralPattern.Value">
            <summary> Get the value for this pattern </summary>
        </member>
        <member name="M:WhitStream.Data.Punctuation.LiteralPattern.Match(System.Object)">
            <summary>
            Returns whether the given value matches the singleton pattern
            </summary>
            <param name="o">The value to match on</param>
            <returns>True if the value is equal to the pattern</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.LiteralPattern.Coerce(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the coercion of the two patterns
            </summary>
            <param name="p">the pattern to coerce</param>
            <returns>the new pattern.</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.LiteralPattern.Uncoerce(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the uncoercion of the two patterns
            </summary>
            <param name="p">the pattern to coerce</param>
            <returns>the new pattern.</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.LiteralPattern.Combine(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the combination of p with this literal pattern
            </summary>
            <param name="p">the pattern to combine with</param>
            <returns>the combined pattern</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.LiteralPattern.Equals(System.Object)">
            <summary>
            Compares LiteralPattern objects for equality
            </summary>
            <param name="obj">the pattern to compare</param>
            <returns>true if the two literals are equal</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.LiteralPattern.ToString">
            <summary>
            A string representation of the pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.LiteralPattern.GetHashCode">
            <summary>Return the hash code of value of this pattern (and not the hash code of the pattern itself)</summary>
            <returns>The value's hash code</returns>
        </member>
        <member name="T:WhitStream.Data.Punctuation.RangePattern">
            <summary>
            A pattern to match on a range of values
            </summary>
        </member>
        <member name="M:WhitStream.Data.Punctuation.RangePattern.#ctor(System.Object,System.Object)">
            <summary>
            Constructs a pattern to match on a range
            Note that the max and min values must support IComparable
            </summary>
            <param name="oMin">The minimum value in the range</param>
            <param name="oMax">The maximum value in the range</param>
            <seealso cref="T:System.IComparable"/>
        </member>
        <member name="P:WhitStream.Data.Punctuation.RangePattern.MinValue">
            <summary> Get the lower bound for this pattern </summary>
        </member>
        <member name="P:WhitStream.Data.Punctuation.RangePattern.MaxValue">
            <summary> Get the upper bound for this pattern </summary>
        </member>
        <member name="M:WhitStream.Data.Punctuation.RangePattern.Match(System.Object)">
            <summary>
            Checks to see if the value is within the pattern's range
            </summary>
            <param name="o">The value to match on</param>
            <returns>True if the value is in the range</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.RangePattern.Equals(System.Object)">
            <summary>
            Compares RangePattern objects for equality
            </summary>
            <param name="obj">the pattern to compare</param>
            <returns>true if the two ranges are equal</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.RangePattern.Coerce(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the coercion of the two patterns
            </summary>
            <param name="p">the pattern to coerce</param>
            <returns>the new pattern.</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.RangePattern.Uncoerce(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the Uncoercion of the two patterns
            </summary>
            <param name="p">the pattern to uncoerce</param>
            <returns>the new pattern.</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.RangePattern.Combine(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the combination of p with this literal pattern
            </summary>
            <param name="p">the pattern to combine with</param>
            <returns>the combined pattern</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.RangePattern.ToString">
            <summary>
            A string representation of the pattern
            </summary>
            <returns></returns>
        </member>
        <member name="T:WhitStream.Data.Punctuation.ListPattern">
            <summary>
            A pattern representing a list of values
            </summary>
        </member>
        <member name="M:WhitStream.Data.Punctuation.ListPattern.#ctor(System.Object[])">
            <summary>
            Constructs a list pattern, given a list of objects
            </summary>
            <param name="rgo">The values to be in the list</param>
        </member>
        <member name="M:WhitStream.Data.Punctuation.ListPattern.#ctor(WhitStream.Data.Punctuation.ListPattern,WhitStream.Data.Punctuation.ListPattern)">
            <summary>
            Merges two ListPatterns into a single listpattern
            </summary>
            <param name="lp1">The first list pattern to merge</param>
            <param name="lp2">The second list pattern to merge</param>
        </member>
        <member name="M:WhitStream.Data.Punctuation.ListPattern.Match(System.Object)">
            <summary>
            Checks to see if the given value is in the list
            </summary>
            <param name="o">The value to match on</param>
            <returns>True if the value is in the list</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.ListPattern.Coerce(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the coercion (union) of the two patterns
            </summary>
            <param name="p">the pattern to coerce</param>
            <returns>the new pattern.</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.ListPattern.Uncoerce(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the uncoercion of the two patterns
            </summary>
            <param name="p">the pattern to uncoerce</param>
            <returns>the new pattern.</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.ListPattern.Combine(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Return the combination of p with this literal pattern
            </summary>
            <param name="p">the pattern to combine with</param>
            <returns>the combined pattern</returns>
        </member>
        <member name="P:WhitStream.Data.Punctuation.ListPattern.Values">
            <summary> Get the literal patterns in this list </summary>
        </member>
        <member name="M:WhitStream.Data.Punctuation.ListPattern.Equals(System.Object)">
            <summary>
            Compares ListPattern objects for equality
            </summary>
            <param name="obj">the pattern to compare</param>
            <returns>true if the two lists are equal</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.ListPattern.ToString">
            <summary>
            A string representation of the pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.#ctor(System.Int32)">
            <summary>
            Constructor for creating a data item with the given number of attributes
            </summary>
            <param name="c">The number of attributes to track</param>
        </member>
        <member name="M:WhitStream.Data.Punctuation.#ctor(WhitStream.Data.Punctuation,System.UInt32)">
            <summary>
            Copy constructor for a punctuation
            </summary>
            <param name="p">The punctuation to copy</param>
            <param name="c">The number of attributes more to track than the copied punctuation</param>
        </member>
        <member name="M:WhitStream.Data.Punctuation.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor to create a punctuation from a serialized one
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:WhitStream.Data.Punctuation.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Override to serialize a punctuation
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:WhitStream.Data.Punctuation.AddValue(System.Object)">
            <summary>
            Add a pattern to this punctuation, and check to see if this punctuation is all wildcards
            </summary>
            <param name="o">the pattern to add</param>
        </member>
        <member name="P:WhitStream.Data.Punctuation.Item(System.Int32)">
            <summary>
            Support indexing on a particular attribute
            </summary>
            <param name="i">The attribute to read/write</param>
            <returns>The value for that attribute</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.Match(WhitStream.Data.DataItem)">
            <summary>
            Returns whether or not this punctuation matches the given data item
            </summary>
            <param name="d">The data item to match on</param>
            <returns>true if the punctuation matches the data item</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.Describes(System.Int32[])">
            <summary>
            Returns whether this punctuation "describes" the given attributes.
            That is, if the punctuation has wildcard values for all attributes
            not in the given list
            </summary>
            <param name="attrs">The attributes to check on</param>
            <returns>true if the punctuation describes the attributes</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.Combine(WhitStream.Data.Punctuation,WhitStream.Data.Punctuation)">
            <summary>
            The combination (intersection) of the given punctuations
            (i.e. p1.match(d) &amp;&amp; p2.match(d) &lt;--&gt; Punctuation.Combine(p1,p2).match(d)
            </summary>
            <param name="p1">One punctuation to combine</param>
            <param name="p2">The other punctuation to combine</param>
            <returns>The punctuation that represents the combination of p1 and p2, or null of none exists</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.Coerce(WhitStream.Data.Punctuation,WhitStream.Data.Punctuation)">
            <summary>
            The coercion (union) of the given punctuations
            (i.e. p1.match(d) || p2.match(d) &lt;--&gt; Punctuation.Coerce(p1,p2).match(d)
            </summary>
            <param name="p1">One punctuation to coerce</param>
            <param name="p2">The other punctuation to coerce</param>
            <returns>The punctuation that represents the coercion of p1 and p2, or null of none exists</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.Uncoerce(WhitStream.Data.Punctuation,WhitStream.Data.Punctuation)">
            <summary>
            The removal (difference) of the second punctuation from the first
            </summary>
            <param name="p1">The original punctuation</param>
            <param name="p2">The punctuation to remove</param>
            <returns>The punctuation that represents the difference of p1 and p2, or null of none exists</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.Flatten">
            <summary> Flatten out all list patterns into literal patterns </summary>
            <returns>The resulting punctuations from flattening the lists</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.Equals(System.Object)">
            <summary>
            Determine if two data items are equal (based on values of attributes)
            </summary>
            <param name="obj">The data item to compare to</param>
            <returns>True if the data items are equal</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.Copy">
            <summary> Make a copy of this punctuation </summary>
            <returns>a copy of this punctuation</returns>
        </member>
        <member name="P:WhitStream.Data.Punctuation.IsAllWildcard">
            <summary> Checks to see if all patterns in this punctuation are wildcards </summary>
        </member>
        <member name="M:WhitStream.Data.Punctuation.ToString">
            <summary>
            Generate a string representation of this punctuation
            </summary>
            <returns>This punctuation in a string representation</returns>
        </member>
        <member name="M:WhitStream.Data.Punctuation.ToByte(WhitStream.Utility.Schema,System.Int32)">
            <summary>
            A byte representation of the punctuation
            </summary>
            <returns></returns>
            <remarks>This is used when sending a punctuation schema to a source.  Create a dummy punctuation that 
            contains the factors, if necessary, for the patterns.
            The byte array has this pattern:
            [type of punctuation][type of pattern][type of value]{[factor],[max-min],[number in list]{[list]...}}...</remarks>
        </member>
        <member name="T:WhitStream.Data.MetaPunctuation">
            <summary>
            Class to model a set of punctuations, to match all against a single data item
            This class is useful when "building up" punctuations.
            </summary>
        </member>
        <member name="M:WhitStream.Data.MetaPunctuation.#ctor(System.Int32)">
            <summary>
            Construct a new MetaPunctuation object
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:WhitStream.Data.MetaPunctuation.Match(WhitStream.Data.DataItem)">
            <summary>
            Returns whether or not this punctuation matches the given data item
            </summary>
            <param name="d">The data item to match on</param>
            <returns>true if the punctuation matches the data item</returns>
        </member>
        <member name="M:WhitStream.Data.MetaPunctuation.Include(WhitStream.Data.Punctuation)">
            <summary>
            Assimilate a punctuation into this meta-punctuation
            </summary>
            <param name="p">The punctuation to include</param>
        </member>
        <member name="M:WhitStream.Data.MetaPunctuation.Remove(WhitStream.Data.Punctuation)">
            <summary>
            Remove the given punctuation from this meta-punctuation
            </summary>
            <param name="p">The punctuation to remove</param>
        </member>
        <member name="T:WhitStream.Data.PunctuationScheme">
            <summary>
            Class to model the blueprint of a punctuation.
            </summary>
        </member>
        <member name="M:WhitStream.Data.PunctuationScheme.#ctor(System.Int32)">
            <summary>
            Construct a new Punctuation Scheme
            </summary>
            <param name="size">The number of attributes of the actual punctuation</param>
        </member>
        <member name="M:WhitStream.Data.PunctuationScheme.AddPattern(WhitStream.Data.Punctuation.Pattern)">
            <summary>
            Add a pattern to the Scheme
            </summary>
            <param name="pattern">The pattern to add to the Scheme</param>
        </member>
        <member name="M:WhitStream.Data.PunctuationScheme.FillWC(System.Int32)">
            <summary>
            Fill the scheme with the requested number of WildCards
            </summary>
            <param name="number">Number of WildCard patterns to be added.  A negative number
            indicates to fill the rest of the Scheme with WildCards.</param>
        </member>
        <member name="P:WhitStream.Data.PunctuationScheme.Item(System.Int32)">
            <summary>
            Support indexing to find patterns in the scheme.
            </summary>
            <param name="i">The attribute to read</param>
            <returns>The value for that attribute</returns>
            <remarks>Read only.</remarks>
        </member>
        <member name="P:WhitStream.Data.PunctuationScheme.Count">
            <summary>
            Gets the current number of patterns in the Scheme
            </summary>
            <remarks>Read only.</remarks>
        </member>
        <member name="P:WhitStream.Data.PunctuationScheme.Capacity">
            <summary>
            Gets the max number of patterns that may be added to the Scheme
            </summary>
            <remarks>Read only.</remarks>
        </member>
        <member name="T:WhitStream.Server.TCPServer">
            <summary>
            Class to receive and manage TCP network connections
            </summary>
        </member>
        <member name="F:WhitStream.Server.TCPServer.WHITSTREAM_PORT">
            <summary> Default WhitStream port </summary>
        </member>
        <member name="T:WhitStream.Server.TCPServer.SetClient">
            <summary> Method to assign an operator to a port for reading data </summary>
            <param name="ns">The network stream to listen to</param>
            <seealso cref="T:WhitStream.QueryEngine.QueryOperators.OpServer"/>
        </member>
        <member name="M:WhitStream.Server.TCPServer.#ctor">
            <summary> Default constructor -- set listening port to default port </summary>
        </member>
        <member name="M:WhitStream.Server.TCPServer.#ctor(System.String,System.Int32)">
            <summary> Constructor for setting specific IP and port </summary>
            <param name="ip">user-defined IP address to listen on</param>
            <param name="port">user-defined port to listen on</param>
        </member>
        <member name="M:WhitStream.Server.TCPServer.AddListener(WhitStream.Server.TCPServer.SetClient)">
            <summary>
            Add a listener (usually a query operator) to the list of listeners.
            When a stream registers with the system, one of the listeners from the
            queue will be assigned to that stream
            </summary>
            <remarks>The listener will listen on the default WhitStream port</remarks>
            <param name="sc">The method to call when a stream is found</param>
        </member>
        <member name="M:WhitStream.Server.TCPServer.AddListener(WhitStream.Server.TCPServer.SetClient,System.Int32)">
            <summary>
            Add a listener (usually a query operator) to the list of listeners.
            When a stream registers with the system, one of the listeners from the
            queue will be assigned to that stream
            </summary>
            <param name="sc">The method to call when a stream is found</param>
            <param name="port">The port to listen on</param>
        </member>
        <member name="T:WhitStream.Server.TCPServer.PortListener">
            <summary>
            Keeps track of a TcpListener on a specific port, as well as all the servers and clients waiting
            </summary>
        </member>
        <member name="T:WhitStream.Utility.Util">
            <summary>
            Utility functions for converting bytes, ints, strings, etc
            </summary>
        </member>
        <member name="F:WhitStream.Utility.Util.TypeByte">
            <summary>
            Static types - byte, ushort, uint
            </summary>
        </member>
        <member name="F:WhitStream.Utility.Util.TypeUShort">
            <summary>
            Static types - byte, ushort, uint
            </summary>
        </member>
        <member name="F:WhitStream.Utility.Util.TypeUInt">
            <summary>
            Static types - byte, ushort, uint
            </summary>
        </member>
        <member name="M:WhitStream.Utility.Util.ByteToUInt(System.Byte[])">
            <summary>
            Converts a byte[4] into an int
            </summary>
            <param name="b"> The byte[4] to be converted into an int </param>
        </member>
        <member name="M:WhitStream.Utility.Util.IntToByte(System.Int32)">
            <summary>
            Converts an int to a byte[4]
            </summary>
            <param name="i"> The int to be converted into a byte[4] </param>
        </member>
        <member name="M:WhitStream.Utility.Util.ByteToString(System.Byte[],System.Int32)">
            <summary>
            Convert a phrase stored in bytes into a string
            </summary>
            <param name="str_in_b">Byte array holding the phrase</param>
            <param name="len">Length of the byte array</param>
        </member>
        <member name="M:WhitStream.Utility.Util.ByteToString(WhitStream.Utility.CyclicQueue,System.Int32)">
            <summary>
            Convert a phrase stored in a cyclic buffer into a string
            </summary>
            <param name="CQ">Cyclic Buffer</param>
            <param name="len">Length of the data in the buffer</param>
        </member>
        <member name="M:WhitStream.Utility.Util.StringToByte(System.String)">
            <summary>
            Convert a phrase stored in a string into bytes
            </summary>
            <param name="str">String array holding the phrase</param>
        </member>
        <member name="M:WhitStream.Utility.Util.ByteToUInt(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Converts a byte[4] into an int
            </summary>
            <param name="b"> The byte[4] to be converted into an int </param>
            <param name="offset"> Where to start in the byte array - the LSB</param>
            <param name="up">If to travel up or down the array</param>
        </member>
        <member name="M:WhitStream.Utility.Util.ByteToUInt(WhitStream.Utility.CyclicQueue,System.Int32,System.Boolean)">
            <summary>
            Converts a Cyclic buffer into an int
            </summary>
            <param name="CQ"> The cyclic buffer to be converted into an int </param>
            <param name="offset"> Where to start in the cyclic buffer</param>
            <param name="up">Whether to go up or down the buffer</param>
            <remarks>This does not convert the entire cyclic buffer.  Merely the next 4 bytes.</remarks>
        </member>
        <member name="M:WhitStream.Utility.Util.ReturnInt(System.Object)">
            <summary>
            Gets the type and returns it as an int
            </summary>
            <param name="di"></param>
        </member>
        <member name="T:WhitStream.Utility.CyclicQueue">
            <summary>
            A simple cyclic queue.  Instead of being an array of objects, this uses an
            array of bytes which make up the objects.  Before the start of each object is
            4 bytes that contain the length of that object
            </summary>
        </member>
        <member name="F:WhitStream.Utility.CyclicQueue.m_cyclicBuffer">
            <summary>
            The cyclic array
            </summary>
            <remarks>Do not use other than within a stream.read() call.
            Use custom indexing to get the byte values.  Needs to be public
            for the read() function call.</remarks>
        </member>
        <member name="M:WhitStream.Utility.CyclicQueue.#ctor(System.Int32)">
            <summary>
            Constructs a cyclic queue
            </summary>
            <param name="q_size">Fixed size of the queue.  Will never change.</param>
        </member>
        <member name="M:WhitStream.Utility.CyclicQueue.New_Index(System.Int32)">
            <summary>
            Gets the index of the where the incoming data item should be put depending on that
            data item's length.  The main function of CyclicQueue.
            </summary>
            <remarks>This also places the length of the incoming data item in the first four bytes.</remarks>
            <param name="len">Length of the data item (in bytes).</param>
            <returns>The next available index to play the data item.</returns>
        </member>
        <member name="M:WhitStream.Utility.CyclicQueue.op_Increment(WhitStream.Utility.CyclicQueue)">
            <summary>
            Overloaded ++ Operator
            </summary>
        </member>
        <member name="P:WhitStream.Utility.CyclicQueue.Item(System.Int32)">
            <summary> Support indexing on the cyclic queue </summary>
            <param name="i">The attribute to read</param>
            <returns>The value for that byte</returns>
            <remarks>This returns the value of the byte 4 passed the index
            of the next object.  In other words - 0 will return the first byte
            of the object.  Read-only</remarks>
        </member>
        <member name="P:WhitStream.Utility.CyclicQueue.Size">
            <summary>
            Gets the size of the array
            </summary>
            <remarks>Read-only</remarks>
        </member>
        <member name="P:WhitStream.Utility.CyclicQueue.Next_Object">
            <summary>
            Gets the index of the next object
            </summary>
            <remarks>Read-only</remarks>
        </member>
        <member name="P:WhitStream.Utility.CyclicQueue.Next_Object_Len">
            <summary>
            Gets the length of the next object
            </summary>
            <remarks>Read-only</remarks>
        </member>
        <member name="P:WhitStream.Utility.CyclicQueue.Total_Count">
            <summary>
            Gets the total count of data items in the queue
            </summary>
            <remarks>Read-only</remarks>
        </member>
        <member name="P:WhitStream.Utility.CyclicQueue.Buffer">
            <summary>
            Get the byte[] buffer for the cyclic queue
            </summary>
        </member>
        <member name="M:WhitStream.Utility.CyclicQueue.IncCount">
            <summary>
            Increments the right count depending on if the buffer has looped
            </summary>
            <remarks>Write-only.  This doesn't return anything useful, just 0.</remarks>
        </member>
        <member name="T:WhitStream.Utility.Schema">
            <summary>
            Holds the packet specification in a list of byte[] so that
            a packet can be parsed correctly
            </summary>
            <remarks>
            The position is in the form start,finish.  For example, an integer will
            be 13,10 such that byte[13] is shifted 24, byte[12] is shifted 16, etc.
            </remarks>
        </member>
        <member name="F:WhitStream.Utility.Schema.attributes">
            <summary>
            Holds the list of attributes that make up the Schema
            </summary>
        </member>
        <member name="M:WhitStream.Utility.Schema.#ctor">
            <summary>
            Constructor to initialize the class
            </summary>
        </member>
        <member name="M:WhitStream.Utility.Schema.AddAttr(System.Int32,System.Int32,System.String)">
            <summary>
            Adds an attribute to the schema
            </summary>
            <param name="MSB"> The most significant byte </param>
            <param name="LSB"> The least significant byte</param>
            <param name="name"> The name of the attribute being store </param>
        </member>
        <member name="P:WhitStream.Utility.Schema.Item(System.Int32)">
            <summary>
            Support indexing on a particular attribute
            </summary>
            <param name="i">The attribute to read/write</param>
            <returns>The value for that attribute</returns>
            <remarks>Read only.</remarks>
        </member>
        <member name="P:WhitStream.Utility.Schema.Count">
            <summary>
            Read only - gets the count of attributes
            </summary>
        </member>
        <member name="P:WhitStream.Utility.Schema.Names">
            <summary>
            Read only - returns a list of all the names in the Schema
            </summary>
        </member>
        <member name="T:WhitStream.Utility.Schema.Attribute">
            <summary>
            Holds an attribute for a dataitem
            </summary>
        </member>
        <member name="F:WhitStream.Utility.Schema.Attribute.msB">
            <summary>
            Most and least significant bytes.  The MSB is shifted over
            24 bits and the LSB is the last byte of an int.
            </summary>
        </member>
        <member name="F:WhitStream.Utility.Schema.Attribute.lsB">
            <summary>
            Most and least significant bytes.  The MSB is shifted over
            24 bits and the LSB is the last byte of an int.
            </summary>
        </member>
        <member name="F:WhitStream.Utility.Schema.Attribute.name">
            <summary>
            Name of the attribute
            </summary>
        </member>
        <member name="F:WhitStream.Utility.Schema.Attribute.t">
            <summary>
            Type of the attribute - byte, ushort, uint
            </summary>
        </member>
        <member name="M:WhitStream.Utility.Schema.Attribute.#ctor(System.Int32,System.Int32,System.String,System.Type)">
            <summary>
            Constructor for an Attribute
            </summary>
        </member>
        <member name="P:WhitStream.Utility.Schema.Attribute.MSB">
            <summary>
            Read only - get the msB
            </summary>
        </member>
        <member name="P:WhitStream.Utility.Schema.Attribute.LSB">
            <summary>
            Read only - get the lsB
            </summary>
        </member>
        <member name="P:WhitStream.Utility.Schema.Attribute.Name">
            <summary>
            Read only - get the name
            </summary>
        </member>
        <member name="P:WhitStream.Utility.Schema.Attribute.Type">
            <summary>
            Read only - get the type
            </summary>
        </member>
        <member name="T:WhitStream.Utility.ConnectionManager">
            <summary>
            Holds a list of connections so that when a connection is needed
            for a query, it is easily found in the list
            </summary>
        </member>
        <member name="M:WhitStream.Utility.ConnectionManager.#ctor(System.String,System.String)">
            <summary>
            Constructor to create the list of connects and create
            a new thread to wait/accept new connections
            </summary>
        </member>
        <member name="M:WhitStream.Utility.ConnectionManager.#ctor(System.String)">
            <summary>
            Constructor to create the list of connects and create
            a new thread to wait/accept new connections
            </summary>
        </member>
        <member name="M:WhitStream.Utility.ConnectionManager.Accept_Socket(System.IAsyncResult)">
            <summary>
            Accepts incoming connections
            </summary>
        </member>
        <member name="M:WhitStream.Utility.ConnectionManager.CheckConnections">
            <summary>
            Check the connections
            </summary>
        </member>
        <member name="M:WhitStream.Utility.ConnectionManager.LocateCon(System.String)">
            <summary>
            Return the connection wanted by the query
            </summary>
            <param name="name"> Name of the connection wanted </param>
        </member>
        <member name="M:WhitStream.Utility.ConnectionManager.LocateCon(System.Int32)">
            <summary>
            Return the connection wanted by the query
            </summary>
            <param name="id"> ID of the connection wanted </param>
        </member>
        <member name="M:WhitStream.Utility.ConnectionManager.LocateCon(System.Int32,System.String)">
            <summary>
            Return the connection wanted by the query
            </summary>
            <param name="id"> ID of the connection wanted </param>
            <param name="name"> Name of the connection wanted </param>
        </member>
        <member name="P:WhitStream.Utility.ConnectionManager.Connections">
            <summary>
            Get a list of all the connections represented as strings
            </summary>
        </member>
        <member name="M:WhitStream.Utility.ConnectionManager.Kill">
            <summary>
            Kills the connection manager
            </summary>
        </member>
        <member name="T:WhitStream.Utility.DataItemPool">
            <summary>
            Class to allocate a pool of data items which get used and then replaced
            </summary>
        </member>
        <member name="T:WhitStream.Utility.DataItemPool.GetDataItem">
            <summary>Get a data item from the data pool</summary>
            <param name="cdi">The number of data items to get</param>
            <returns>A array of data items to manipulate</returns>
        </member>
        <member name="T:WhitStream.Utility.DataItemPool.ReleaseDataItem">
            <summary>Return a data item to the pool</summary>
            <param name="di">the data item to return</param>
        </member>
        <member name="F:WhitStream.Utility.DataItemPool.m_dataQueue">
            <summary>
            Queue to hold a pool of data items
            </summary>
        </member>
        <member name="P:WhitStream.Utility.DataItemPool.DICount">
            <summary> How many data items are currently in the queue </summary>
        </member>
        <member name="F:WhitStream.Utility.DataItemPool.m_initCount">
            <summary>
            The initial count created
            </summary>
            <remarks>Useful for determining how many more data items to create</remarks>
        </member>
        <member name="F:WhitStream.Utility.DataItemPool.m_attributeCount">
            <summary>
            Number of attributes in the data items
            </summary>
        </member>
        <member name="M:WhitStream.Utility.DataItemPool.Init(System.Int32,System.Boolean)">
            <summary>
            Initialize this class to allocate a number of dataitems for a given pool
            </summary>
            <param name="count">Number of initial dataitems to queue up</param>
            <param name="fGlob">Is this pool global or local to this thread</param>
        </member>
        <member name="M:WhitStream.Utility.DataItemPool.Init(System.Int32)">
            <summary> Initialize a local data item pool </summary>
            <param name="count">Number of data items to queue</param>
        </member>
        <member name="M:WhitStream.Utility.DataItemPool.CreateMoreDataItems(System.Int32)">
            <summary>
            Create more data items for the system to use
            </summary>
            <param name="count">The count to create</param>
            <returns>False if we ran out of memory, true otherwise</returns>
        </member>
        <member name="M:WhitStream.Utility.DataItemPool.DeleteSomeDataItems(System.Int32)">
            <summary>
            Delete some data items from the queue (to clean up memory)
            </summary>
            <param name="count">The count to delete</param>
            <returns>False if didn't delete count, else true</returns>
            <remarks>Not sure why a false return would be necessary.</remarks>
        </member>
        <member name="M:WhitStream.Utility.DataItemPool.GetItem(System.Int32)">
            <summary>
            Return a data item from the pool
            </summary>
            <returns>A fresh dataitem</returns>
            <remarks>If there are no more data items, it creates some more</remarks>
        </member>
        <member name="M:WhitStream.Utility.DataItemPool.GetItem">
            <summary>
            Return a data item from the pool
            </summary>
            <returns>A fresh dataitem</returns>
            <remarks>If there are no more data items, it creates some more</remarks>
        </member>
        <member name="M:WhitStream.Utility.DataItemPool.ReleaseItem(WhitStream.Data.DataItem)">
            <summary>
            Give an item back to the pool
            </summary>
            <param name="item">The item to give back</param>
        </member>
        <member name="M:WhitStream.Utility.DataItemPool.ToString">
            <summary>
            Get the current state of this data pool
            </summary>
            <returns>String containing the current state</returns>
        </member>
        <member name="T:WhitStream.Utility.Log">
            <summary>
            Log class to output text to the console/file
            </summary>
        </member>
        <member name="T:WhitStream.Utility.Log.eMessageType">
            <summary>
            Type of messages to be written to a log file
            </summary>
        </member>
        <member name="F:WhitStream.Utility.Log.eMessageType.Error">
            <summary>
            Red text
            </summary>
        </member>
        <member name="F:WhitStream.Utility.Log.eMessageType.Debug">
            <summary>
            Grey text
            </summary>
        </member>
        <member name="F:WhitStream.Utility.Log.eMessageType.Normal">
            <summary>
            White text
            </summary>
        </member>
        <member name="F:WhitStream.Utility.Log.m_consoleEnabled">
            <summary>
            Shall we output to the console
            </summary>
        </member>
        <member name="M:WhitStream.Utility.Log.WriteMessage(System.String,WhitStream.Utility.Log.eMessageType)">
            <summary>
            Outputs an error message in red
            </summary>
            <param name="message">message to write</param>
            <param name="type">Which type of message shall we send</param>
        </member>
        <member name="M:WhitStream.Utility.Log.Init(System.String,System.Boolean)">
            <summary>
            Initialize the log files
            </summary>
            <param name="filename">The filename we should create - appends the date to it</param>
            <param name="consoleEnabled">Whether we should output to the console</param>
        </member>
        <member name="M:WhitStream.Utility.Log.Close">
            <summary>
            Close the log file
            </summary>
        </member>
    </members>
</doc>
